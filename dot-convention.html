<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dot Convention — Mutual Inductance</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{font-size:1.5em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.92em;text-align:center;max-width:820px}

  .tabs{display:flex;gap:6px;margin:10px 0;flex-wrap:wrap;justify-content:center}
  .tab{padding:8px 18px;border-radius:8px;cursor:pointer;font-size:.88em;
    background:#161b22;border:1px solid #30363d;color:#8b949e;transition:.2s}
  .tab:hover{border-color:#58a6ff;color:#e6edf3}
  .tab.active{background:#1f6feb;border-color:#1f6feb;color:white;font-weight:bold}

  .main{max-width:1000px;width:100%;margin-top:8px}
  .row{display:flex;gap:14px;flex-wrap:wrap;justify-content:center}
  .panel{background:#161b22;border-radius:12px;padding:16px;border:1px solid #30363d;margin-bottom:12px;flex:1;min-width:300px}
  .panel-full{flex-basis:100%}
  .panel h2{font-size:.9em;color:#8b949e;margin-bottom:8px;text-align:center}
  canvas{display:block;margin:0 auto;border-radius:8px}

  .controls{display:flex;gap:14px;flex-wrap:wrap;justify-content:center;align-items:center;
    background:#161b22;border:1px solid #30363d;border-radius:10px;padding:10px 16px;
    margin-bottom:10px;max-width:960px;width:100%}
  .cg{display:flex;align-items:center;gap:6px}
  .cg label{font-size:.82em;color:#8b949e;white-space:nowrap}
  input[type="range"]{width:90px;accent-color:#58a6ff}
  .cv{font-size:.82em;color:#58a6ff;min-width:55px;font-family:'Courier New',monospace}

  .dot-bar{display:flex;gap:10px;margin-bottom:10px;justify-content:center;align-items:center;flex-wrap:wrap}
  .dot-btn{padding:8px 16px;border-radius:8px;cursor:pointer;font-size:.88em;
    background:#161b22;border:2px solid #30363d;color:#8b949e;transition:.2s;display:flex;align-items:center;gap:6px}
  .dot-btn:hover{border-color:#58a6ff;color:#e6edf3}
  .dot-btn .dot-circle{width:14px;height:14px;border-radius:50%;display:inline-block}
  .dot-btn.l1 .dot-circle{background:#f97583}
  .dot-btn.l2 .dot-circle{background:#79c0ff}
  .rule-badge{background:#21262d;border:1px solid #30363d;border-radius:8px;padding:6px 14px;
    font-size:.82em;color:#d2a8ff;font-family:'Courier New',monospace;text-align:center}

  .results{background:#161b22;border:1px solid #30363d;border-radius:10px;padding:14px 18px;
    margin-bottom:12px;max-width:960px;width:100%}
  .results h2{font-size:.9em;color:#8b949e;margin-bottom:8px;text-align:center}
  .res-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:8px}
  .res-item{background:#0d1117;border-radius:8px;padding:8px 12px;text-align:center}
  .res-label{font-size:.72em;color:#7d8590;margin-bottom:2px}
  .res-val{font-size:1.05em;font-family:'Courier New',monospace;font-weight:bold}

  .formula-box{background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:12px 14px;
    margin-top:8px;font-size:.84em;color:#8b949e;line-height:1.8;text-align:center}
  .formula-box .f{color:#f78166;font-family:'Courier New',monospace}
  .formula-box .h{color:#e0e0ff;font-weight:bold}
  .formula-box .sign{color:#d2a8ff;font-weight:bold;font-size:1.1em;padding:0 2px}

  .info{max-width:960px;width:100%;background:#161b22;border-radius:12px;
    padding:14px 18px;border:1px solid #30363d;margin-top:10px;font-size:.84em;line-height:1.6;color:#8b949e}
  .info strong{color:#e0e0ff}
  a{color:#58a6ff}
</style>
</head>
<body>

<h1>Dot Convention — Mutual Inductance</h1>
<p class="subtitle">Explore how dot placement determines the sign of mutual inductance M in circuit equations</p>

<div class="tabs">
  <div class="tab active" data-mode="coupled">Coupled Circuit</div>
  <div class="tab" data-mode="series">Series Connection</div>
</div>

<div class="dot-bar" id="dotBar">
  <button class="dot-btn l1" id="dot1Btn" onclick="toggleDot(1)">
    <span class="dot-circle"></span> L₁ dot: Top
  </button>
  <button class="dot-btn l2" id="dot2Btn" onclick="toggleDot(2)">
    <span class="dot-circle"></span> L₂ dot: Top
  </button>
  <div class="rule-badge" id="ruleBadge">Sign: −M</div>
</div>

<div class="controls" id="coupledControls">
  <div class="cg">
    <label>L₁:</label>
    <input type="range" id="sL1" min="10" max="500" step="10" value="100">
    <span class="cv" id="sL1V">100 mH</span>
  </div>
  <div class="cg">
    <label>L₂:</label>
    <input type="range" id="sL2" min="10" max="500" step="10" value="100">
    <span class="cv" id="sL2V">100 mH</span>
  </div>
  <div class="cg">
    <label>k:</label>
    <input type="range" id="sK" min="0" max="1" step="0.01" value="0.8">
    <span class="cv" id="sKV">0.80</span>
  </div>
  <div class="cg">
    <label>Freq:</label>
    <input type="range" id="sF" min="10" max="500" step="5" value="60">
    <span class="cv" id="sFV">60 Hz</span>
  </div>
  <div class="cg">
    <label>V<sub>s</sub>:</label>
    <input type="range" id="sVs" min="1" max="240" step="1" value="120">
    <span class="cv" id="sVsV">120 V</span>
  </div>
  <div class="cg">
    <label>R₁:</label>
    <input type="range" id="sR1" min="0.5" max="20" step="0.5" value="5">
    <span class="cv" id="sR1V">5.0 Ω</span>
  </div>
  <div class="cg">
    <label>R<sub>L</sub>:</label>
    <input type="range" id="sRL" min="1" max="50" step="1" value="10">
    <span class="cv" id="sRLV">10 Ω</span>
  </div>
</div>

<div class="results" id="resBox">
  <h2 id="resTitle">Coupled Circuit Results</h2>
  <div class="res-grid" id="resGrid"></div>
  <div class="formula-box" id="formulaBox"></div>
</div>

<div class="main">
  <div class="row">
    <div class="panel panel-full">
      <h2>Circuit Diagram</h2>
      <canvas id="circuitCanvas" width="960" height="380"></canvas>
    </div>
  </div>
  <div class="row">
    <div class="panel">
      <h2>Phasor Diagram</h2>
      <canvas id="phasorCanvas" width="340" height="300"></canvas>
    </div>
    <div class="panel">
      <h2>Dot Convention Rule</h2>
      <div id="ruleExplain" style="font-size:.86em;line-height:1.7;color:#8b949e;padding:8px"></div>
    </div>
  </div>
</div>

<div class="info">
  <strong>Dot Convention:</strong> The dot marks the polarity reference terminal of each coil.
  If current <em>enters</em> the dotted terminal of one coil, it induces a <em>positive</em> voltage at the dotted terminal of the other coil.<br>
  <strong>Sign Rule:</strong> In mesh analysis, if both mesh currents enter (or both leave) their respective dotted terminals, the mutual term is <strong>+M</strong>. Otherwise it is <strong>−M</strong>.<br>
  <strong>Series Aiding:</strong> L<sub>eq</sub> = L₁ + L₂ + 2M &nbsp;|&nbsp;
  <strong>Series Opposing:</strong> L<sub>eq</sub> = L₁ + L₂ − 2M<br><br>
  <a href="index.html">← All Demos</a> ·
  <a href="mutual-inductance.html">Mutual Inductance</a> ·
  <a href="transformer.html">Transformer</a> ·
  <a href="3phase-circuit.html">3-Phase Circuit</a>
</div>

<script>
// ── State ──
let mode = 'coupled';
let dot1Top = true;
let dot2Top = true;
let seriesAiding = true;

// ── Tabs ──
const tabs = document.querySelectorAll('.tab');
tabs.forEach(t => t.addEventListener('click', () => {
  tabs.forEach(x => x.classList.remove('active'));
  t.classList.add('active');
  mode = t.dataset.mode;
  updateUI();
}));

function toggleDot(n) {
  if (mode === 'coupled') {
    if (n === 1) dot1Top = !dot1Top;
    else dot2Top = !dot2Top;
  } else {
    seriesAiding = !seriesAiding;
  }
  compute();
}

// ── Sliders ──
const sliders = [
  ['sL1','sL1V', v => v + ' mH'],
  ['sL2','sL2V', v => v + ' mH'],
  ['sK','sKV', v => parseFloat(v).toFixed(2)],
  ['sF','sFV', v => v + ' Hz'],
  ['sVs','sVsV', v => v + ' V'],
  ['sR1','sR1V', v => parseFloat(v).toFixed(1) + ' Ω'],
  ['sRL','sRLV', v => v + ' Ω'],
];
sliders.forEach(([id, vid, fmt]) => {
  document.getElementById(id).oninput = function() {
    document.getElementById(vid).textContent = fmt(this.value);
    compute();
  };
});

// ── Complex arithmetic ──
function C(r, i) { return {r, i}; }
function cAdd(a, b) { return {r: a.r+b.r, i: a.i+b.i}; }
function cSub(a, b) { return {r: a.r-b.r, i: a.i-b.i}; }
function cMul(a, b) { return {r: a.r*b.r-a.i*b.i, i: a.r*b.i+a.i*b.r}; }
function cDiv(a, b) { const d=b.r*b.r+b.i*b.i; return {r:(a.r*b.r+a.i*b.i)/d, i:(a.i*b.r-a.r*b.i)/d}; }
function cMag(a) { return Math.sqrt(a.r*a.r+a.i*a.i); }
function cAng(a) { return Math.atan2(a.i, a.r)*180/Math.PI; }
function cScale(a, s) { return {r: a.r*s, i: a.i*s}; }

// ── Canvases ──
const circC = document.getElementById('circuitCanvas');
const phasC = document.getElementById('phasorCanvas');
const cCtx = circC.getContext('2d');
const pCtx = phasC.getContext('2d');

// ── Results ──
let res = {};

function fmt(v) { return Math.abs(v) < 10 ? v.toFixed(3) : Math.abs(v) < 100 ? v.toFixed(2) : v.toFixed(1); }
function fmtA(deg) { return (deg >= 0 ? '+' : '') + deg.toFixed(1) + '°'; }

function compute() {
  const L1 = +document.getElementById('sL1').value / 1000;
  const L2 = +document.getElementById('sL2').value / 1000;
  const k = +document.getElementById('sK').value;
  const f = +document.getElementById('sF').value;
  const Vs = +document.getElementById('sVs').value;
  const R1 = +document.getElementById('sR1').value;
  const RL = +document.getElementById('sRL').value;
  const w = 2 * Math.PI * f;
  const M = k * Math.sqrt(L1 * L2);

  if (mode === 'coupled') {
    // Sign: I1 enters L1_top, I2 enters L2_bot (clockwise meshes)
    // Same-side dots → one enters dot, one doesn't → sM = -1
    // Opposite dots → both enter (or both leave) → sM = +1
    const sM = (dot1Top === dot2Top) ? -1 : 1;

    // Mesh equations:
    // Z11·I1 + Z12·I2 = Vs
    // Z21·I1 + Z22·I2 = 0
    const Z11 = C(R1, w * L1);
    const Z12 = C(0, sM * w * M);
    const Z21 = C(0, sM * w * M);
    const Z22 = C(RL, w * L2);
    const Vsc = C(Vs, 0);

    // Cramer's rule
    const det = cSub(cMul(Z11, Z22), cMul(Z12, Z21));
    const I1 = cDiv(cMul(Vsc, Z22), det);
    const I2 = cDiv(cScale(cMul(Vsc, Z21), -1), det);

    // Load voltage
    const VL = cScale(I2, RL);
    // Voltage across L1 (self + mutual)
    const VL1 = cAdd(cMul(C(0, w * L1), I1), cMul(C(0, sM * w * M), I2));
    // Power
    const Pload = 0.5 * cMag(VL) * cMag(I2) * Math.cos((cAng(VL) - cAng(I2)) * Math.PI / 180);

    res = {
      mode: 'coupled', sM, M, L1, L2, k, f, w, Vs, R1, RL,
      I1, I2, VL, VL1, Pload,
      Z11, Z12, Z22, det
    };
  } else {
    // Series connection
    const Leq_aid = L1 + L2 + 2 * M;
    const Leq_opp = L1 + L2 - 2 * M;
    const Leq = seriesAiding ? Leq_aid : Leq_opp;
    // Single mesh: Vs = I·(R1 + RL + jωLeq)
    const Ztot = C(R1 + RL, w * Leq);
    const I = cDiv(C(Vs, 0), Ztot);
    const VRL_c = cScale(I, RL);

    res = {
      mode: 'series', M, L1, L2, k, f, w, Vs, R1, RL,
      seriesAiding, Leq, Leq_aid, Leq_opp,
      I, VRL: VRL_c
    };
  }

  updateUI();
}

function updateUI() {
  // Dot buttons
  if (mode === 'coupled') {
    document.getElementById('dot1Btn').innerHTML =
      '<span class="dot-circle"></span> L₁ dot: ' + (dot1Top ? 'Top' : 'Bottom');
    document.getElementById('dot2Btn').innerHTML =
      '<span class="dot-circle"></span> L₂ dot: ' + (dot2Top ? 'Top' : 'Bottom');
    document.getElementById('dot1Btn').style.display = '';
    document.getElementById('dot2Btn').style.display = '';

    const sM = (dot1Top === dot2Top) ? -1 : 1;
    const badge = document.getElementById('ruleBadge');
    badge.textContent = 'Sign: ' + (sM > 0 ? '+M' : '−M');
    badge.style.color = sM > 0 ? '#3fb950' : '#f97583';
    badge.style.borderColor = sM > 0 ? '#3fb95040' : '#f9758340';
  } else {
    document.getElementById('dot1Btn').innerHTML =
      '<span class="dot-circle"></span> ' + (seriesAiding ? 'Series Aiding' : 'Series Opposing');
    document.getElementById('dot1Btn').style.display = '';
    document.getElementById('dot2Btn').style.display = 'none';

    const badge = document.getElementById('ruleBadge');
    badge.textContent = seriesAiding ? 'L_eq = L₁+L₂+2M' : 'L_eq = L₁+L₂−2M';
    badge.style.color = seriesAiding ? '#3fb950' : '#f97583';
    badge.style.borderColor = seriesAiding ? '#3fb95040' : '#f9758340';
  }

  updateResults();
  drawCircuit();
  drawPhasors();
  updateRule();
}

function updateResults() {
  const r = res;
  let items = [];
  let formula = '';

  if (r.mode === 'coupled') {
    const sSign = r.sM > 0 ? '+' : '−';
    items = [
      {label: 'M (mutual)', val: (r.M * 1000).toFixed(1) + ' mH', color: '#d2a8ff'},
      {label: '|I₁| (primary)', val: fmt(cMag(r.I1)) + ' A', color: '#f97583'},
      {label: '∠I₁', val: fmtA(cAng(r.I1)), color: '#f97583'},
      {label: '|I₂| (secondary)', val: fmt(cMag(r.I2)) + ' A', color: '#79c0ff'},
      {label: '∠I₂', val: fmtA(cAng(r.I2)), color: '#79c0ff'},
      {label: '|V_load|', val: fmt(cMag(r.VL)) + ' V', color: '#3fb950'},
      {label: '∠V_load', val: fmtA(cAng(r.VL)), color: '#3fb950'},
      {label: 'P_load (avg)', val: fmt(r.Pload) + ' W', color: '#d29922'},
    ];
    formula = '<span class="h">Mesh 1 (primary):</span> ';
    formula += '<span class="f">V<sub>s</sub> = I₁·(R₁ + jωL₁) <span class="sign">' + sSign + '</span> jωM·I₂</span><br>';
    formula += '<span class="h">Mesh 2 (secondary):</span> ';
    formula += '<span class="f">0 = <span class="sign">' + sSign + '</span> jωM·I₁ + I₂·(R<sub>L</sub> + jωL₂)</span><br>';
    formula += '<span class="h">Values:</span> ';
    formula += '<span class="f">ωL₁ = ' + fmt(r.w * r.L1) + ' Ω, ωL₂ = ' + fmt(r.w * r.L2) + ' Ω, ωM = ' + fmt(r.w * r.M) + ' Ω</span>';
  } else {
    items = [
      {label: 'M (mutual)', val: (r.M * 1000).toFixed(1) + ' mH', color: '#d2a8ff'},
      {label: 'L_eq (aiding)', val: (r.Leq_aid * 1000).toFixed(1) + ' mH', color: '#3fb950'},
      {label: 'L_eq (opposing)', val: (r.Leq_opp * 1000).toFixed(1) + ' mH', color: '#f97583'},
      {label: 'L_eq (current)', val: (r.Leq * 1000).toFixed(1) + ' mH', color: '#58a6ff'},
      {label: '|I|', val: fmt(cMag(r.I)) + ' A', color: '#f78166'},
      {label: '∠I', val: fmtA(cAng(r.I)), color: '#f78166'},
      {label: '|V_load|', val: fmt(cMag(r.VRL)) + ' V', color: '#3fb950'},
    ];
    const sSign = r.seriesAiding ? '+' : '−';
    formula = '<span class="h">' + (r.seriesAiding ? 'Series Aiding:' : 'Series Opposing:') + '</span> ';
    formula += '<span class="f">L<sub>eq</sub> = L₁ + L₂ <span class="sign">' + sSign + '</span> 2M = ';
    formula += (r.L1 * 1000).toFixed(0) + ' + ' + (r.L2 * 1000).toFixed(0) + ' ' + sSign + ' 2×' + (r.M * 1000).toFixed(1);
    formula += ' = ' + (r.Leq * 1000).toFixed(1) + ' mH</span><br>';
    formula += '<span class="h">Mesh:</span> <span class="f">V<sub>s</sub> = I·(R₁ + R<sub>L</sub> + jωL<sub>eq</sub>)</span>';
  }

  document.getElementById('resTitle').textContent = (r.mode === 'coupled' ? 'Coupled Circuit' : 'Series Connection') + ' Results';
  let html = '';
  items.forEach(it => {
    html += '<div class="res-item"><div class="res-label">' + it.label + '</div>' +
      '<div class="res-val" style="color:' + it.color + '">' + it.val + '</div></div>';
  });
  document.getElementById('resGrid').innerHTML = html;
  document.getElementById('formulaBox').innerHTML = formula;
}

function updateRule() {
  const el = document.getElementById('ruleExplain');
  if (res.mode === 'coupled') {
    const i1enters = dot1Top; // I1 enters top = dot if dot is on top
    const i2enters = !dot2Top; // I2 enters bottom = dot if dot is on bottom
    const sM = (dot1Top === dot2Top) ? -1 : 1;

    let html = '<div style="margin-bottom:10px">';
    html += '<strong style="color:#e0e0ff">Current vs. Dot Analysis:</strong></div>';
    html += '<div style="background:#0d1117;border-radius:8px;padding:10px;margin-bottom:8px">';
    html += '<span style="color:#f97583">I₁</span> enters <strong>' + (dot1Top ? 'top' : 'bottom') + '</strong> of L₁ ';
    html += '(dot is on <strong>' + (dot1Top ? 'top' : 'bottom') + '</strong>) → ';
    html += i1enters
      ? '<span style="color:#3fb950">enters dot ✓</span>'
      : '<span style="color:#f97583">leaves dot ✗</span>';
    html += '<br>';
    html += '<span style="color:#79c0ff">I₂</span> enters <strong>bottom</strong> of L₂ ';
    html += '(dot is on <strong>' + (dot2Top ? 'top' : 'bottom') + '</strong>) → ';
    html += i2enters
      ? '<span style="color:#3fb950">enters dot ✓</span>'
      : '<span style="color:#f97583">leaves dot ✗</span>';
    html += '</div>';

    if (sM > 0) {
      html += '<div style="color:#3fb950;font-weight:bold">Both enter (or both leave) dotted terminals → <span style="font-size:1.2em">+M</span></div>';
    } else {
      html += '<div style="color:#f97583;font-weight:bold">One enters dot, one leaves dot → <span style="font-size:1.2em">−M</span></div>';
    }
    html += '<div style="margin-top:8px;font-size:.82em;color:#7d8590">';
    html += 'The sign of M in the mesh impedance matrix determines whether the mutual coupling aids or opposes.';
    html += '</div>';
    el.innerHTML = html;
  } else {
    let html = '<div style="margin-bottom:10px">';
    html += '<strong style="color:#e0e0ff">Series Connection:</strong></div>';
    html += '<div style="background:#0d1117;border-radius:8px;padding:10px;margin-bottom:8px">';
    if (res.seriesAiding) {
      html += '<span style="color:#3fb950;font-weight:bold">Series Aiding</span>: ';
      html += 'Current enters dotted terminal of both coils (dots on same end of series path).<br>';
      html += 'Fluxes <strong>reinforce</strong> each other → higher L<sub>eq</sub>';
    } else {
      html += '<span style="color:#f97583;font-weight:bold">Series Opposing</span>: ';
      html += 'Current enters dot of one coil, leaves dot of the other (dots on opposite ends).<br>';
      html += 'Fluxes <strong>oppose</strong> each other → lower L<sub>eq</sub>';
    }
    html += '</div>';
    html += '<div style="margin-top:6px;font-size:.85em">';
    html += '<span style="color:#3fb950">Aiding:</span> L<sub>eq</sub> = L₁ + L₂ + 2M = <strong>' + (res.Leq_aid * 1000).toFixed(1) + ' mH</strong><br>';
    html += '<span style="color:#f97583">Opposing:</span> L<sub>eq</sub> = L₁ + L₂ − 2M = <strong>' + (res.Leq_opp * 1000).toFixed(1) + ' mH</strong>';
    html += '</div>';
    el.innerHTML = html;
  }
}

// ── Circuit Drawing ──
function drawCircuit() {
  const W = circC.width, H = circC.height;
  const ctx = cCtx;
  ctx.clearRect(0, 0, W, H);

  if (res.mode === 'coupled') {
    drawCoupledCircuit(ctx, W, H);
  } else {
    drawSeriesCircuit(ctx, W, H);
  }
}

function drawCoupledCircuit(ctx, W, H) {
  const topY = 90, botY = 290, cy = 190;
  const vsX = 70;       // source center
  const r1X1 = 150, r1X2 = 275;
  const l1X = 340;      // L1 center x
  const l2X = 500;      // L2 center x
  const rlX1 = 570, rlX2 = 695;
  const retX = 750;     // right-side return wire

  const bumpR = 12;
  const numBumps = 4;
  const coilTop = cy - numBumps * bumpR;
  const coilBot = cy + numBumps * bumpR;

  // ── Background boxes ──
  ctx.fillStyle = '#161b2210';
  ctx.strokeStyle = '#30363d30'; ctx.lineWidth = 1; ctx.setLineDash([6, 4]);
  roundRect(ctx, 30, 50, retX / 2 - 15, H - 80, 10); ctx.fill(); ctx.stroke();
  roundRect(ctx, retX / 2 + 25, 50, retX / 2 - 15, H - 80, 10); ctx.fill(); ctx.stroke();
  ctx.setLineDash([]);

  // Labels
  ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = '#484f58';
  ctx.fillText('Primary Mesh', (vsX + l1X) / 2, 66);
  ctx.fillText('Secondary Mesh', (l2X + retX) / 2, 66);

  // ── Wires ──
  ctx.lineWidth = 2;
  // Primary top: Vs+ → R1 → L1_top
  ctx.strokeStyle = '#f9758380';
  drawWire(ctx, [[vsX, cy - 30], [vsX, topY], [r1X1, topY]]);
  drawWire(ctx, [[r1X2, topY], [l1X, topY]]);
  // Primary bottom: L1_bot → Vs-
  drawWire(ctx, [[l1X, botY], [vsX, botY], [vsX, cy + 30]]);

  // Secondary top: L2_top → RL
  ctx.strokeStyle = '#79c0ff80';
  drawWire(ctx, [[l2X, topY], [rlX1, topY]]);
  drawWire(ctx, [[rlX2, topY], [retX, topY], [retX, cy - 10]]);
  // Secondary bottom: L2_bot → return
  drawWire(ctx, [[l2X, botY], [retX, botY], [retX, cy + 10]]);

  // ── Components ──
  // AC Source
  drawACSource(ctx, vsX, cy, 25, '#ffa657');
  ctx.fillStyle = '#ffa657'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Vs', vsX - 36, cy + 5);
  ctx.fillText(res.Vs + ' V', vsX, cy + 44);
  // + / - polarity
  ctx.font = 'bold 13px sans-serif';
  ctx.fillText('+', vsX + 10, cy - 28);
  ctx.fillText('−', vsX + 10, cy + 36);

  // R1
  drawZigzagH(ctx, r1X1, topY, r1X2, '#f9758380');
  ctx.fillStyle = '#f97583'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('R₁', (r1X1 + r1X2) / 2, topY - 16);

  // RL (load)
  drawZigzagH(ctx, rlX1, topY, rlX2, '#3fb95080');
  ctx.fillStyle = '#3fb950'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('R_L', (rlX1 + rlX2) / 2, topY - 16);

  // L1 (inductor bumps facing right)
  drawInductorV(ctx, l1X, coilTop, numBumps, bumpR, '#f97583', 1);
  ctx.fillStyle = '#f97583'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('L₁', l1X - 24, cy + 5);

  // L2 (inductor bumps facing left)
  drawInductorV(ctx, l2X, coilTop, numBumps, bumpR, '#79c0ff', -1);
  ctx.fillStyle = '#79c0ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('L₂', l2X + 24, cy + 5);

  // Wire from L1_top to coilTop and L1_bot to coilBot
  ctx.strokeStyle = '#f9758380'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(l1X, topY); ctx.lineTo(l1X, coilTop); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(l1X, coilBot); ctx.lineTo(l1X, botY); ctx.stroke();

  ctx.strokeStyle = '#79c0ff80';
  ctx.beginPath(); ctx.moveTo(l2X, topY); ctx.lineTo(l2X, coilTop); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(l2X, coilBot); ctx.lineTo(l2X, botY); ctx.stroke();

  // ── Coupling (M) ──
  const coupMidX = (l1X + l2X) / 2;
  ctx.strokeStyle = '#d2a8ff50'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.moveTo(coupMidX - 10, coilTop + 10); ctx.lineTo(coupMidX - 10, coilBot - 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(coupMidX + 10, coilTop + 10); ctx.lineTo(coupMidX + 10, coilBot - 10); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#d2a8ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('M', coupMidX, cy + 5);
  ctx.font = '10px sans-serif'; ctx.fillStyle = '#d2a8ff80';
  ctx.fillText('k=' + res.k.toFixed(2), coupMidX, cy + 20);

  // ── Dots ──
  const dotR = 9;
  const dot1Y = dot1Top ? coilTop + 4 : coilBot - 4;
  const dot2Y = dot2Top ? coilTop + 4 : coilBot - 4;

  // Dot 1
  ctx.beginPath(); ctx.arc(l1X + 16, dot1Y, dotR, 0, Math.PI * 2);
  ctx.fillStyle = '#f97583'; ctx.fill();
  ctx.strokeStyle = '#0d1117'; ctx.lineWidth = 2; ctx.stroke();

  // Dot 2
  ctx.beginPath(); ctx.arc(l2X - 16, dot2Y, dotR, 0, Math.PI * 2);
  ctx.fillStyle = '#79c0ff'; ctx.fill();
  ctx.strokeStyle = '#0d1117'; ctx.lineWidth = 2; ctx.stroke();

  // Dot labels
  ctx.font = 'bold 9px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillStyle = '#0d1117';
  ctx.fillText('●', l1X + 16, dot1Y);
  ctx.fillText('●', l2X - 16, dot2Y);
  ctx.textBaseline = 'alphabetic';

  // ── Current arrows ──
  // I1 arrow on top wire (going right)
  drawCurrentArrow(ctx, (r1X2 + l1X) / 2, topY, 1, '#f97583');
  ctx.fillStyle = '#f97583'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('I₁', (r1X2 + l1X) / 2, topY - 14);

  // I2 arrow on secondary top wire (going right)
  drawCurrentArrow(ctx, (l2X + rlX1) / 2, topY, 1, '#79c0ff');
  ctx.fillStyle = '#79c0ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('I₂', (l2X + rlX1) / 2, topY - 14);

  // I1 arrow on bottom wire (going left)
  drawCurrentArrow(ctx, (vsX + l1X) / 2, botY, -1, '#f9758360');

  // I2 arrow on bottom wire (going left)
  drawCurrentArrow(ctx, (l2X + retX) / 2, botY, -1, '#79c0ff60');

  // ── Terminal labels ──
  ctx.font = '10px sans-serif'; ctx.textAlign = 'right';
  ctx.fillStyle = '#8b949e';
  ctx.fillText('top', l1X - 6, topY + 4);
  ctx.fillText('bot', l1X - 6, botY + 4);
  ctx.textAlign = 'left';
  ctx.fillText('top', l2X + 6, topY + 4);
  ctx.fillText('bot', l2X + 6, botY + 4);

  // ── Sign indicator between coils ──
  const sM = (dot1Top === dot2Top) ? -1 : 1;
  ctx.font = 'bold 16px sans-serif'; ctx.textAlign = 'center';
  ctx.fillStyle = sM > 0 ? '#3fb950' : '#f97583';
  ctx.fillText(sM > 0 ? '+M' : '−M', coupMidX, coilTop - 6);

  // ── Computed values on diagram ──
  if (res.I1) {
    ctx.font = '10px monospace'; ctx.textAlign = 'center';
    ctx.fillStyle = '#f9758380';
    ctx.fillText('|I₁|=' + fmt(cMag(res.I1)) + 'A', (r1X2 + l1X) / 2, topY + 16);
    ctx.fillStyle = '#79c0ff80';
    ctx.fillText('|I₂|=' + fmt(cMag(res.I2)) + 'A', (l2X + rlX1) / 2, topY + 16);
    ctx.fillStyle = '#3fb95080';
    ctx.fillText('|V_L|=' + fmt(cMag(res.VL)) + 'V', (rlX1 + rlX2) / 2, topY + 28);
  }

  // ── Mesh direction arcs ──
  ctx.strokeStyle = '#f9758330'; ctx.lineWidth = 1.5;
  drawMeshArc(ctx, (vsX + l1X) / 2, cy, 40, '#f9758340');
  drawMeshArc(ctx, (l2X + retX) / 2, cy, 40, '#79c0ff40');
}

function drawSeriesCircuit(ctx, W, H) {
  const cy = 190, topY = 110, botY = 270;
  const vsX = 120;
  const l1X = 340, l2X = 500;
  const rlX = 680;
  const bumpR = 12;
  const numBumps = 4;
  const coilTop = cy - numBumps * bumpR;
  const coilBot = cy + numBumps * bumpR;

  // Wires
  ctx.strokeStyle = '#f7816680'; ctx.lineWidth = 2;
  // Top wire: Vs → L1_top
  drawWire(ctx, [[vsX, cy - 30], [vsX, topY], [l1X, topY]]);
  // L1_top to coilTop
  ctx.beginPath(); ctx.moveTo(l1X, topY); ctx.lineTo(l1X, coilTop); ctx.stroke();
  // L1_bot → L2 connection (top or bottom depending on aiding)
  ctx.beginPath(); ctx.moveTo(l1X, coilBot); ctx.lineTo(l1X, botY); ctx.stroke();
  if (seriesAiding) {
    // Aiding: L1_bot connects to L2_top
    drawWire(ctx, [[l1X, botY], [l2X, botY]]);
    ctx.beginPath(); ctx.moveTo(l2X, botY); ctx.lineTo(l2X, coilBot); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(l2X, coilTop); ctx.lineTo(l2X, topY); ctx.stroke();
    drawWire(ctx, [[l2X, topY], [rlX, topY], [rlX, cy - 10]]);
  } else {
    // Opposing: L1_bot connects to L2_bot
    drawWire(ctx, [[l1X, botY], [l2X, botY]]);
    ctx.beginPath(); ctx.moveTo(l2X, botY); ctx.lineTo(l2X, coilBot); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(l2X, coilTop); ctx.lineTo(l2X, topY); ctx.stroke();
    drawWire(ctx, [[l2X, topY], [rlX, topY], [rlX, cy - 10]]);
  }
  // Bottom return: RL → Vs
  drawWire(ctx, [[rlX, cy + 10], [rlX, botY + 30], [vsX, botY + 30], [vsX, cy + 30]]);

  // AC Source
  drawACSource(ctx, vsX, cy, 25, '#ffa657');
  ctx.fillStyle = '#ffa657'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Vs', vsX - 36, cy + 5);
  ctx.fillText(res.Vs + ' V', vsX, cy + 44);
  ctx.font = 'bold 13px sans-serif';
  ctx.fillText('+', vsX + 10, cy - 28);
  ctx.fillText('−', vsX + 10, cy + 36);

  // RL
  drawZigzagV(ctx, rlX, cy, '#3fb95080');
  ctx.fillStyle = '#3fb950'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'left';
  ctx.fillText('R_L', rlX + 18, cy + 5);

  // L1
  drawInductorV(ctx, l1X, coilTop, numBumps, bumpR, '#f97583', 1);
  ctx.fillStyle = '#f97583'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('L₁', l1X - 24, cy + 5);

  // L2
  drawInductorV(ctx, l2X, coilTop, numBumps, bumpR, '#79c0ff', -1);
  ctx.fillStyle = '#79c0ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('L₂', l2X + 24, cy + 5);

  // Coupling
  const coupMidX = (l1X + l2X) / 2;
  ctx.strokeStyle = '#d2a8ff50'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.moveTo(coupMidX - 10, coilTop + 10); ctx.lineTo(coupMidX - 10, coilBot - 10); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(coupMidX + 10, coilTop + 10); ctx.lineTo(coupMidX + 10, coilBot - 10); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#d2a8ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('M', coupMidX, cy + 5);

  // Dots for series connection
  const dotR = 9;
  if (seriesAiding) {
    // Aiding: dots on same end (both at bottom = connected end)
    // L1 dot at bottom, L2 dot at bottom (where they connect)
    drawDot(ctx, l1X + 16, coilBot - 4, '#f97583', dotR);
    drawDot(ctx, l2X - 16, coilBot - 4, '#79c0ff', dotR);
    ctx.fillStyle = '#3fb950'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Series Aiding (+2M)', coupMidX, coilTop - 12);
  } else {
    // Opposing: dots on opposite ends
    // L1 dot at bottom, L2 dot at top
    drawDot(ctx, l1X + 16, coilBot - 4, '#f97583', dotR);
    drawDot(ctx, l2X - 16, coilTop + 4, '#79c0ff', dotR);
    ctx.fillStyle = '#f97583'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Series Opposing (−2M)', coupMidX, coilTop - 12);
  }

  // Current arrow
  drawCurrentArrow(ctx, (vsX + l1X) / 2, topY, 1, '#f78166');
  ctx.fillStyle = '#f78166'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('I', (vsX + l1X) / 2, topY - 14);

  // Connection label
  ctx.fillStyle = '#8b949e'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('connected', (l1X + l2X) / 2, botY + 14);

  // L_eq label
  if (res.Leq) {
    ctx.fillStyle = '#58a6ff'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('L_eq = ' + (res.Leq * 1000).toFixed(1) + ' mH', coupMidX, botY + 46);
  }

  // Computed values
  if (res.I) {
    ctx.font = '10px monospace'; ctx.textAlign = 'center';
    ctx.fillStyle = '#f7816680';
    ctx.fillText('|I|=' + fmt(cMag(res.I)) + 'A', (vsX + l1X) / 2, topY + 16);
  }
}

// ── Drawing Helpers ──

function drawWire(ctx, points) {
  if (points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(points[0][0], points[0][1]);
  for (let i = 1; i < points.length; i++) ctx.lineTo(points[i][0], points[i][1]);
  ctx.stroke();
}

function drawACSource(ctx, cx, cy, r, color) {
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = '#0d1117'; ctx.fill();
  ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke();
  // Sine wave
  ctx.strokeStyle = color; ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let t = -1; t <= 1; t += 0.04) {
    const px = cx + t * (r - 6);
    const py = cy - Math.sin(t * Math.PI) * (r * 0.4);
    t === -1 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.stroke();
}

function drawZigzagH(ctx, x1, y, x2, color) {
  const len = x2 - x1;
  const segs = 6;
  const segW = len / segs;
  const amp = 8;
  ctx.strokeStyle = color; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x1, y);
  for (let s = 0; s < segs; s++) {
    const sx = x1 + s * segW;
    ctx.lineTo(sx + segW * 0.25, y - amp);
    ctx.lineTo(sx + segW * 0.75, y + amp);
    ctx.lineTo(sx + segW, y);
  }
  ctx.stroke();
}

function drawZigzagV(ctx, x, cy, color) {
  const halfH = 24;
  const segs = 5;
  const segH = (halfH * 2) / segs;
  const amp = 8;
  const y1 = cy - halfH;
  ctx.strokeStyle = color; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y1);
  for (let s = 0; s < segs; s++) {
    const sy = y1 + s * segH;
    ctx.lineTo(x + amp, sy + segH * 0.25);
    ctx.lineTo(x - amp, sy + segH * 0.75);
    ctx.lineTo(x, sy + segH);
  }
  ctx.stroke();
}

function drawInductorV(ctx, x, yTop, numBumps, bumpR, color, dir) {
  // dir: 1 = bumps to right, -1 = bumps to left
  const bumpW = 14 * dir;
  ctx.strokeStyle = color; ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let i = 0; i < numBumps; i++) {
    const cy = yTop + (2 * i + 1) * bumpR;
    // Semicircle: bulges in direction of 'dir'
    if (dir > 0) {
      ctx.arc(x, cy, bumpR, -Math.PI / 2, Math.PI / 2, false);
    } else {
      ctx.arc(x, cy, bumpR, Math.PI / 2, -Math.PI / 2, false);
    }
  }
  ctx.stroke();
}

function drawDot(ctx, x, y, color, r) {
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fillStyle = color; ctx.fill();
  ctx.strokeStyle = '#0d1117'; ctx.lineWidth = 2; ctx.stroke();
}

function drawCurrentArrow(ctx, x, y, dir, color) {
  // dir: 1 = right, -1 = left
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + 10 * dir, y);
  ctx.lineTo(x - 5 * dir, y - 5);
  ctx.lineTo(x - 5 * dir, y + 5);
  ctx.closePath();
  ctx.fill();
}

function drawMeshArc(ctx, cx, cy, r, color) {
  ctx.strokeStyle = color; ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0.3, Math.PI * 2 - 0.3);
  ctx.stroke();
  // Arrowhead (clockwise)
  const angle = -0.3;
  const ax = cx + r * Math.cos(angle);
  const ay = cy + r * Math.sin(angle);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(ax + 4, ay + 6);
  ctx.lineTo(ax - 6, ay + 2);
  ctx.lineTo(ax - 2, ay - 6);
  ctx.closePath();
  ctx.fill();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ── Phasor Diagram ──
function drawPhasors() {
  const W = phasC.width, H = phasC.height;
  const ctx = pCtx;
  ctx.clearRect(0, 0, W, H);
  const cx = W / 2, cy = H / 2;
  const maxR = Math.min(W, H) / 2 - 30;

  // Grid
  ctx.strokeStyle = '#ffffff08'; ctx.lineWidth = 1;
  for (let r = maxR / 3; r <= maxR; r += maxR / 3) {
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
  }
  ctx.strokeStyle = '#ffffff15';
  ctx.beginPath(); ctx.moveTo(10, cy); ctx.lineTo(W - 10, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 10); ctx.lineTo(cx, H - 10); ctx.stroke();

  if (res.mode === 'coupled' && res.I1) {
    // Scale to fit
    const maxMag = Math.max(cMag(res.I1), cMag(res.I2), cMag(res.VL) / (+document.getElementById('sVs').value || 1)) || 1;
    const VsMag = +document.getElementById('sVs').value;
    const vScale = maxR * 0.7 / VsMag;
    const iScale = maxR * 0.5 / (Math.max(cMag(res.I1), cMag(res.I2)) || 1);

    // Vs (reference, angle 0)
    drawPhasorArrow(ctx, cx, cy, 0, VsMag * vScale, '#ffa657', 2.5, 'Vs');
    // VL
    drawPhasorArrow(ctx, cx, cy, cAng(res.VL) * Math.PI / 180, cMag(res.VL) * vScale, '#3fb950', 2, 'V_L');
    // I1
    drawPhasorArrow(ctx, cx, cy, cAng(res.I1) * Math.PI / 180, cMag(res.I1) * iScale, '#f97583', 2, 'I₁');
    // I2
    drawPhasorArrow(ctx, cx, cy, cAng(res.I2) * Math.PI / 180, cMag(res.I2) * iScale, '#79c0ff', 2, 'I₂');

    // Angle arc between Vs and I1
    if (Math.abs(cAng(res.I1)) > 1) {
      const arcR = 25;
      ctx.strokeStyle = '#d2a8ff60'; ctx.lineWidth = 1.2;
      ctx.beginPath();
      const a1 = 0, a2 = -cAng(res.I1) * Math.PI / 180;
      ctx.arc(cx, cy, arcR, a1, a2, cAng(res.I1) > 0);
      ctx.stroke();
      ctx.fillStyle = '#d2a8ff'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
      const am = (a1 + a2) / 2;
      ctx.fillText('θ', cx + Math.cos(am) * (arcR + 10), cy + Math.sin(am) * (arcR + 10) + 3);
    }

    // Legend
    ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
    ctx.fillStyle = '#8b949e';
    ctx.fillText('Solid: Voltage  |  Dashed: Current', 8, H - 8);
  } else if (res.mode === 'series' && res.I) {
    const VsMag = +document.getElementById('sVs').value;
    const scale = maxR * 0.7 / VsMag;
    const iScale = maxR * 0.5 / (cMag(res.I) || 1);

    drawPhasorArrow(ctx, cx, cy, 0, VsMag * scale, '#ffa657', 2.5, 'Vs');
    drawPhasorArrow(ctx, cx, cy, cAng(res.VRL) * Math.PI / 180, cMag(res.VRL) * scale, '#3fb950', 2, 'V_L');
    drawPhasorArrow(ctx, cx, cy, cAng(res.I) * Math.PI / 180, cMag(res.I) * iScale, '#f78166', 2, 'I');

    ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
    ctx.fillStyle = '#8b949e';
    ctx.fillText('Solid: Voltage  |  Arrow: Current', 8, H - 8);
  }
}

function drawPhasorArrow(ctx, cx, cy, angle, length, color, width, label) {
  const ex = cx + Math.cos(angle) * length;
  const ey = cy - Math.sin(angle) * length;
  ctx.strokeStyle = color; ctx.lineWidth = width;
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ex, ey); ctx.stroke();
  // Arrowhead
  const hl = 8;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(ex, ey);
  ctx.lineTo(ex - hl * Math.cos(angle - 0.3), ey + hl * Math.sin(angle - 0.3));
  ctx.lineTo(ex - hl * Math.cos(angle + 0.3), ey + hl * Math.sin(angle + 0.3));
  ctx.closePath(); ctx.fill();
  // Label
  const lx = cx + Math.cos(angle) * (length + 14);
  const ly = cy - Math.sin(angle) * (length + 14);
  ctx.fillStyle = color; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(label, lx, ly + 4);
}

// ── Init ──
compute();
</script>
</body>
</html>
