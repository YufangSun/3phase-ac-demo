<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Absorption &amp; Elimination Theorems — Boolean Algebra</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{font-size:1.5em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.92em;text-align:center;max-width:820px}

  /* Tabs */
  .tabs{display:flex;gap:6px;margin:10px 0;flex-wrap:wrap;justify-content:center}
  .tab{padding:8px 18px;border-radius:8px;cursor:pointer;font-size:.86em;
    background:#161b22;border:1px solid #30363d;color:#8b949e;transition:.2s}
  .tab:hover{border-color:#58a6ff;color:#e6edf3}
  .tab.active{background:#1f6feb;border-color:#1f6feb;color:white;font-weight:bold}

  .main{max-width:1100px;width:100%;margin-top:10px}
  .row{display:flex;flex-wrap:wrap;gap:14px;justify-content:center;margin-bottom:14px}
  .panel{background:#161b22;border-radius:12px;padding:16px;border:1px solid #30363d;flex:1;min-width:300px}
  .panel h2{font-size:.95em;color:#8b949e;margin-bottom:10px;text-align:center}

  /* Theorem box */
  .theorem-box{background:#0d1117;border:1px solid #30363d;border-radius:10px;
    padding:14px 20px;text-align:center;margin-bottom:14px;max-width:900px;width:100%}
  .theorem-box .label{font-size:.8em;color:#8b949e;margin-bottom:6px}
  .expr{font-size:1.15em;font-family:'Courier New',monospace;letter-spacing:.5px;margin:4px 0}
  .expr .term{color:#3fb950}
  .expr .absorbed{color:#f97583;text-decoration:line-through;text-decoration-thickness:2px}
  .expr .op{color:#8b949e}
  .expr .eq{color:#d2a8ff}
  .expr .hl{color:#f0883e}

  /* Truth table */
  .tt-wrap{overflow-x:auto}
  .tt{border-collapse:collapse;width:100%;font-size:.85em;font-family:'Courier New',monospace}
  .tt th{background:#21262d;color:#8b949e;padding:6px 10px;border:1px solid #30363d;
    font-size:.78em;white-space:nowrap}
  .tt td{padding:6px 10px;border:1px solid #30363d;text-align:center;transition:background .15s}
  .tt td.v1{color:#3fb950;font-weight:bold}
  .tt td.v0{color:#484f58}
  .tt .match{background:#3fb95012}
  .tt .sep{border-left:2px solid #58a6ff}

  /* K-map */
  canvas{display:block;border-radius:10px}

  /* Proof */
  .proof{font-family:'Courier New',monospace;font-size:.92em;line-height:2}
  .proof .step{opacity:0.25;transition:opacity .3s}
  .proof .step.visible{opacity:1}
  .proof .step .rule{color:#8b949e;font-size:.8em}
  .proof .step .hi{color:#f0883e}
  .proof .step .result{color:#3fb950}

  /* Buttons */
  button{background:#238636;color:white;border:none;padding:6px 14px;border-radius:6px;
    cursor:pointer;font-size:.82em;transition:.2s}
  button:hover{background:#2ea043}
  button.sec{background:#30363d}
  button.sec:hover{background:#484f58}
  .btn-row{display:flex;gap:8px;justify-content:center;margin-top:10px;flex-wrap:wrap}

  .dual-box{background:#0d1117;border:1px solid #30363d;border-radius:10px;
    padding:12px 18px;margin-top:10px;font-family:'Courier New',monospace;font-size:.9em;line-height:1.9}
  .dual-box .label{font-size:.78em;color:#8b949e;margin-bottom:4px;font-family:'Segoe UI',system-ui,sans-serif}

  .info{max-width:800px;width:100%;margin-top:16px;padding:14px 18px;
    background:#161b22;border-radius:12px;border:1px solid #30363d;font-size:.85em;line-height:1.7;color:#8b949e}
  .info a{color:#58a6ff;text-decoration:none}
  .info a:hover{text-decoration:underline}

  .section{display:none}
  .section.active{display:block}
</style>
</head>
<body>
<h1>Boolean Algebra Theorems</h1>
<p class="subtitle">Two key simplification theorems: Absorption removes redundant terms, Elimination removes redundant complements.</p>

<div class="tabs">
  <div class="tab active" onclick="switchTab(0)">Absorption</div>
  <div class="tab" onclick="switchTab(1)">Elimination</div>
</div>

<!-- ═══════ ABSORPTION ═══════ -->
<div class="section active" id="sec0">

<div class="theorem-box">
  <div class="label">ABSORPTION THEOREM</div>
  <div class="expr">
    <span class="term">X</span> <span class="op">+</span>
    <span class="absorbed">XY</span> <span class="eq">=</span>
    <span class="term">X</span>
  </div>
  <div style="font-size:.78em;color:#7d8590;margin-top:4px">If X is true, XY is already included — the XY term is <span style="color:#f97583">absorbed</span></div>
</div>

<div class="main">
  <div class="row">
    <div class="panel" style="max-width:400px">
      <h2>Truth Table</h2>
      <div class="tt-wrap">
        <table class="tt" id="ttAbsorb"></table>
      </div>
      <div style="margin-top:8px;font-size:.78em;color:#7d8590;text-align:center">
        <span style="color:#3fb950">&#9632;</span> Output columns always match
      </div>
    </div>

    <div class="panel" style="max-width:400px">
      <h2>Karnaugh Map</h2>
      <canvas id="kmapAbsorb" width="380" height="240"></canvas>
    </div>
  </div>

  <div class="row">
    <div class="panel" style="max-width:440px">
      <h2>Venn Diagram</h2>
      <canvas id="vennAbsorb" width="400" height="280"></canvas>
    </div>

    <div class="panel" style="max-width:520px">
      <h2>Algebraic Proof</h2>
      <div class="proof" id="proofAbsorb"></div>
      <div class="btn-row">
        <button onclick="nextStep(0)">Next Step</button>
        <button class="sec" onclick="showAllSteps(0)">Show All</button>
        <button class="sec" onclick="resetSteps(0)">Reset</button>
      </div>
      <div class="dual-box">
        <div class="label">DUAL FORM</div>
        <span style="color:#3fb950">X</span><span style="color:#8b949e"> · </span><span style="color:#f97583;text-decoration:line-through">(X + Y)</span> <span style="color:#d2a8ff">=</span> <span style="color:#3fb950">X</span>
        <div style="font-size:.78em;color:#7d8590;margin-top:4px">By duality: replace + ↔ · , 0 ↔ 1</div>
      </div>
    </div>
  </div>
</div>
</div>

<!-- ═══════ ELIMINATION ═══════ -->
<div class="section" id="sec1">

<div class="theorem-box">
  <div class="label">ELIMINATION THEOREM</div>
  <div class="expr">
    <span class="term">X</span> <span class="op">+</span>
    <span class="hl">X'Y</span> <span class="eq">=</span>
    <span class="term">X</span> <span class="op">+</span>
    <span class="term">Y</span>
  </div>
  <div style="font-size:.78em;color:#7d8590;margin-top:4px">The complement X' is <span style="color:#f0883e">eliminated</span> — only Y matters in the second term</div>
</div>

<div class="main">
  <div class="row">
    <div class="panel" style="max-width:440px">
      <h2>Truth Table</h2>
      <div class="tt-wrap">
        <table class="tt" id="ttElim"></table>
      </div>
      <div style="margin-top:8px;font-size:.78em;color:#7d8590;text-align:center">
        <span style="color:#3fb950">&#9632;</span> Output columns always match
      </div>
    </div>

    <div class="panel" style="max-width:400px">
      <h2>Karnaugh Map</h2>
      <canvas id="kmapElim" width="380" height="240"></canvas>
    </div>
  </div>

  <div class="row">
    <div class="panel" style="max-width:440px">
      <h2>Venn Diagram</h2>
      <canvas id="vennElim" width="400" height="280"></canvas>
    </div>

    <div class="panel" style="max-width:520px">
      <h2>Algebraic Proof</h2>
      <div class="proof" id="proofElim"></div>
      <div class="btn-row">
        <button onclick="nextStep(1)">Next Step</button>
        <button class="sec" onclick="showAllSteps(1)">Show All</button>
        <button class="sec" onclick="resetSteps(1)">Reset</button>
      </div>
      <div class="dual-box">
        <div class="label">DUAL FORM</div>
        <span style="color:#3fb950">X</span><span style="color:#8b949e"> · </span><span style="color:#f0883e">(X' + Y)</span> <span style="color:#d2a8ff">=</span> <span style="color:#3fb950">X</span><span style="color:#8b949e"> · </span><span style="color:#3fb950">Y</span>
        <div style="font-size:.78em;color:#7d8590;margin-top:4px">By duality: replace + ↔ · , 0 ↔ 1</div>
      </div>
    </div>
  </div>
</div>
</div>

<div class="info">
  <strong>Absorption Theorem:</strong> X + XY = X — if X is already true, adding XY contributes nothing new. The larger term is "absorbed" by the smaller.<br>
  <strong>Elimination Theorem:</strong> X + X'Y = X + Y — when X is true the whole expression is true regardless; when X is false, only Y matters, so X' is redundant.<br>
  <strong>Application:</strong> Both are fundamental tools for simplifying Boolean expressions and reducing gate count in digital circuits.<br><br>
  <a href="index.html">&larr; All Demos</a> &middot;
  <a href="consensus.html">Consensus Theorem</a> &middot;
  <a href="kmap.html">K-Map Simplifier</a> &middot;
  <a href="binary-arithmetic.html">Binary Arithmetic</a>
</div>

<script>
// ── Tab switching ──
function switchTab(idx) {
  document.querySelectorAll('.tab').forEach((t, i) => t.classList.toggle('active', i === idx));
  document.querySelectorAll('.section').forEach((s, i) => s.classList.toggle('active', i === idx));
}

// ── Shared helpers ──
function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ═══════════════════════════════════════════
// ABSORPTION: X + XY = X
// ═══════════════════════════════════════════

// Truth table
function buildTTAbsorb() {
  const hdr = ['X', 'Y', '', 'XY', '', 'X + XY', 'X'];
  let html = '<thead><tr>';
  hdr.forEach((h, i) => {
    if (i === 2 || i === 4) html += '<th style="border:none;width:4px;padding:0"></th>';
    else html += '<th' + (i >= 5 ? ' class="sep"' : '') + '>' + h + '</th>';
  });
  html += '</tr></thead><tbody>';
  for (let i = 0; i < 4; i++) {
    const X = (i >> 1) & 1, Y = i & 1;
    const XY = X & Y;
    const lhs = X | XY, rhs = X;
    html += '<tr>';
    html += '<td class="v' + X + '">' + X + '</td>';
    html += '<td class="v' + Y + '">' + Y + '</td>';
    html += '<td style="border:none;width:4px;padding:0"></td>';
    html += '<td class="v' + XY + '">' + XY + '</td>';
    html += '<td style="border:none;width:4px;padding:0"></td>';
    html += '<td class="v' + lhs + ' sep match">' + lhs + '</td>';
    html += '<td class="v' + rhs + ' match">' + rhs + '</td>';
    html += '</tr>';
  }
  html += '</tbody>';
  document.getElementById('ttAbsorb').innerHTML = html;
}

// K-map: 2-variable (X rows, Y cols)
function drawKmapAbsorb() {
  const c = document.getElementById('kmapAbsorb');
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  const cellW = 80, cellH = 64;
  const sx = 110, sy = 70;

  // Headers
  ctx.font = 'bold 14px "Courier New", monospace';
  ctx.fillStyle = '#bc8cff'; ctx.textAlign = 'center';
  ctx.fillText('Y', sx + cellW, sy - 38);
  ctx.save();
  ctx.translate(sx - 38, sy + cellH);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('X', 0, 0);
  ctx.restore();

  ctx.font = '13px "Courier New", monospace';
  ctx.fillStyle = '#8b949e';
  ctx.fillText('0', sx + cellW / 2, sy - 10);
  ctx.fillText('1', sx + cellW + cellW / 2, sy - 10);
  ctx.fillText('0', sx - 18, sy + cellH / 2 + 5);
  ctx.fillText('1', sx - 18, sy + cellH + cellH / 2 + 5);

  // X + XY = X: F = X → row 0: [0,0], row 1: [1,1]
  const vals = [[0, 0], [1, 1]];
  for (let r = 0; r < 2; r++) {
    for (let c2 = 0; c2 < 2; c2++) {
      const x = sx + c2 * cellW, y = sy + r * cellH;
      ctx.fillStyle = vals[r][c2] ? '#3fb95018' : '#0d1117';
      ctx.fillRect(x, y, cellW, cellH);
      ctx.strokeStyle = '#30363d'; ctx.lineWidth = 1;
      ctx.strokeRect(x, y, cellW, cellH);
      ctx.font = 'bold 20px "Courier New", monospace';
      ctx.fillStyle = vals[r][c2] ? '#3fb950' : '#484f58';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(vals[r][c2], x + cellW / 2, y + cellH / 2);

      // Minterm
      const m = r * 2 + c2;
      ctx.font = '10px sans-serif'; ctx.fillStyle = '#484f58';
      ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
      ctx.fillText('m' + m, x + cellW - 4, y + cellH - 3);
    }
  }

  // Group: X covers entire row 1 (both cells)
  const pad = 6;
  ctx.strokeStyle = '#3fb950'; ctx.lineWidth = 3; ctx.setLineDash([]);
  roundRect(ctx, sx - pad, sy + cellH - pad, cellW * 2 + pad * 2, cellH + pad * 2, 12);
  ctx.stroke();
  ctx.font = 'bold 12px sans-serif'; ctx.fillStyle = '#3fb950';
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  ctx.fillText('X', sx + cellW * 2 + pad + 8, sy + cellH);

  // XY group (absorbed): just cell (1,1)
  ctx.strokeStyle = '#f97583'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
  roundRect(ctx, sx + cellW - pad + 3, sy + cellH - pad + 3, cellW + pad * 2 - 6, cellH + pad * 2 - 6, 10);
  ctx.stroke(); ctx.setLineDash([]);
  ctx.font = 'bold 12px sans-serif'; ctx.fillStyle = '#f97583';
  ctx.fillText('XY (absorbed)', sx + cellW * 2 + pad + 8, sy + cellH + 20);
}

// Venn diagram
function drawVennAbsorb() {
  const c = document.getElementById('vennAbsorb');
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  const cx = W / 2, cy = H / 2 - 10;
  const r = 80, d = 45;
  const xc = { x: cx - d, y: cy }, yc = { x: cx + d, y: cy };

  // Fill X circle (green)
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2);
  ctx.fillStyle = '#3fb95030'; ctx.fill();

  // XY intersection (red dashed — absorbed)
  ctx.save();
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2); ctx.clip();
  ctx.beginPath(); ctx.arc(yc.x, yc.y, r, 0, Math.PI * 2);
  ctx.fillStyle = '#f9758320'; ctx.fill();
  ctx.setLineDash([5, 4]); ctx.strokeStyle = '#f97583'; ctx.lineWidth = 2; ctx.stroke();
  ctx.restore(); ctx.setLineDash([]);

  // Circle outlines
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2);
  ctx.strokeStyle = '#3fb950'; ctx.lineWidth = 2; ctx.stroke();
  ctx.beginPath(); ctx.arc(yc.x, yc.y, r, 0, Math.PI * 2);
  ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 2; ctx.stroke();

  // Labels
  ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillStyle = '#3fb950'; ctx.fillText('X', xc.x - 45, xc.y - 50);
  ctx.fillStyle = '#58a6ff'; ctx.fillText('Y', yc.x + 45, yc.y - 50);

  ctx.font = '13px sans-serif';
  ctx.fillStyle = '#3fb950'; ctx.fillText('X', xc.x - 20, xc.y);
  ctx.fillStyle = '#f97583'; ctx.fillText('XY', cx, cy);

  ctx.font = '11px sans-serif'; ctx.fillStyle = '#7d8590';
  ctx.fillText('XY is entirely inside X — absorbed', W / 2, H - 12);
}

// Proof
const absorbProof = [
  { text: '  X + <span class="hi">XY</span>', rule: 'given expression' },
  { text: '= X·<span class="hi">1</span> + XY', rule: 'identity: X·1 = X' },
  { text: '= X·(<span class="hi">1 + Y</span>)', rule: 'factor out X' },
  { text: '= X·<span class="hi">1</span>', rule: 'dominance: 1 + Y = 1' },
  { text: '= <span class="result">X</span>', rule: 'identity: X·1 = X  ∎' },
];

// ═══════════════════════════════════════════
// ELIMINATION: X + X'Y = X + Y
// ═══════════════════════════════════════════

function buildTTElim() {
  const hdr = ['X', 'Y', '', "X'Y", '', "X + X'Y", 'X + Y'];
  let html = '<thead><tr>';
  hdr.forEach((h, i) => {
    if (i === 2 || i === 4) html += '<th style="border:none;width:4px;padding:0"></th>';
    else html += '<th' + (i >= 5 ? ' class="sep"' : '') + '>' + h + '</th>';
  });
  html += '</tr></thead><tbody>';
  for (let i = 0; i < 4; i++) {
    const X = (i >> 1) & 1, Y = i & 1;
    const XpY = (~X & 1) & Y;
    const lhs = X | XpY, rhs = X | Y;
    html += '<tr>';
    html += '<td class="v' + X + '">' + X + '</td>';
    html += '<td class="v' + Y + '">' + Y + '</td>';
    html += '<td style="border:none;width:4px;padding:0"></td>';
    html += '<td class="v' + XpY + '">' + XpY + '</td>';
    html += '<td style="border:none;width:4px;padding:0"></td>';
    html += '<td class="v' + lhs + ' sep match">' + lhs + '</td>';
    html += '<td class="v' + rhs + ' match">' + rhs + '</td>';
    html += '</tr>';
  }
  html += '</tbody>';
  document.getElementById('ttElim').innerHTML = html;
}

function drawKmapElim() {
  const c = document.getElementById('kmapElim');
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  const cellW = 80, cellH = 64;
  const sx = 110, sy = 70;

  ctx.font = 'bold 14px "Courier New", monospace';
  ctx.fillStyle = '#bc8cff'; ctx.textAlign = 'center';
  ctx.fillText('Y', sx + cellW, sy - 38);
  ctx.save();
  ctx.translate(sx - 38, sy + cellH);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('X', 0, 0);
  ctx.restore();

  ctx.font = '13px "Courier New", monospace';
  ctx.fillStyle = '#8b949e';
  ctx.fillText('0', sx + cellW / 2, sy - 10);
  ctx.fillText('1', sx + cellW + cellW / 2, sy - 10);
  ctx.fillText('0', sx - 18, sy + cellH / 2 + 5);
  ctx.fillText('1', sx - 18, sy + cellH + cellH / 2 + 5);

  // X + Y: row0=[0,1], row1=[1,1]
  const vals = [[0, 1], [1, 1]];
  for (let r = 0; r < 2; r++) {
    for (let c2 = 0; c2 < 2; c2++) {
      const x = sx + c2 * cellW, y = sy + r * cellH;
      ctx.fillStyle = vals[r][c2] ? '#3fb95018' : '#0d1117';
      ctx.fillRect(x, y, cellW, cellH);
      ctx.strokeStyle = '#30363d'; ctx.lineWidth = 1;
      ctx.strokeRect(x, y, cellW, cellH);
      ctx.font = 'bold 20px "Courier New", monospace';
      ctx.fillStyle = vals[r][c2] ? '#3fb950' : '#484f58';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(vals[r][c2], x + cellW / 2, y + cellH / 2);

      const m = r * 2 + c2;
      ctx.font = '10px sans-serif'; ctx.fillStyle = '#484f58';
      ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
      ctx.fillText('m' + m, x + cellW - 4, y + cellH - 3);
    }
  }

  const pad = 6;

  // X group: entire row 1 (green)
  ctx.strokeStyle = '#3fb950'; ctx.lineWidth = 3; ctx.setLineDash([]);
  roundRect(ctx, sx - pad, sy + cellH - pad, cellW * 2 + pad * 2, cellH + pad * 2, 12);
  ctx.stroke();
  ctx.font = 'bold 12px sans-serif'; ctx.fillStyle = '#3fb950';
  ctx.textAlign = 'left'; ctx.textBaseline = 'top';
  ctx.fillText('X', sx + cellW * 2 + pad + 8, sy + cellH);

  // Y group: entire col 1 (blue)
  ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 3;
  roundRect(ctx, sx + cellW - pad, sy - pad, cellW + pad * 2, cellH * 2 + pad * 2, 12);
  ctx.stroke();
  ctx.fillStyle = '#58a6ff';
  ctx.fillText('Y', sx + cellW * 2 + pad + 8, sy - pad);

  // X'Y (original): just cell (0,1) — orange dashed
  ctx.strokeStyle = '#f0883e'; ctx.lineWidth = 2; ctx.setLineDash([6, 4]);
  roundRect(ctx, sx + cellW - pad + 3, sy - pad + 3, cellW + pad * 2 - 6, cellH + pad * 2 - 6, 10);
  ctx.stroke(); ctx.setLineDash([]);
  ctx.font = 'bold 11px sans-serif'; ctx.fillStyle = '#f0883e';
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  ctx.fillText("X'Y → simplifies to Y", sx + cellW, sy + cellH * 2 + pad + 8);
}

function drawVennElim() {
  const c = document.getElementById('vennElim');
  const ctx = c.getContext('2d');
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  const cx = W / 2, cy = H / 2 - 10;
  const r = 80, d = 45;
  const xc = { x: cx - d, y: cy }, yc = { x: cx + d, y: cy };

  // Fill X circle (green)
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2);
  ctx.fillStyle = '#3fb95025'; ctx.fill();

  // Fill X'Y region (Y minus X intersection) — orange
  ctx.save();
  ctx.beginPath(); ctx.arc(yc.x, yc.y, r, 0, Math.PI * 2); ctx.clip();
  // Fill all of Y
  ctx.fillStyle = '#f0883e20';
  ctx.fillRect(0, 0, W, H);
  // Cut out X
  ctx.globalCompositeOperation = 'destination-out';
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,1)'; ctx.fill();
  ctx.restore();

  // Redraw X fill (was cut)
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2);
  ctx.fillStyle = '#3fb95025'; ctx.fill();

  // Show that X + X'Y = X + Y: highlight entire Y circle too
  ctx.beginPath(); ctx.arc(yc.x, yc.y, r, 0, Math.PI * 2);
  ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 2; ctx.stroke();
  ctx.beginPath(); ctx.arc(xc.x, xc.y, r, 0, Math.PI * 2);
  ctx.strokeStyle = '#3fb950'; ctx.lineWidth = 2; ctx.stroke();

  // Labels
  ctx.font = 'bold 18px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillStyle = '#3fb950'; ctx.fillText('X', xc.x - 45, xc.y - 50);
  ctx.fillStyle = '#58a6ff'; ctx.fillText('Y', yc.x + 45, yc.y - 50);

  ctx.font = '13px sans-serif';
  ctx.fillStyle = '#3fb950'; ctx.fillText('X', xc.x - 20, xc.y);
  ctx.fillStyle = '#f0883e'; ctx.fillText("X'Y", yc.x + 20, yc.y);

  ctx.font = '11px sans-serif'; ctx.fillStyle = '#7d8590';
  ctx.fillText("X + X'Y covers the same area as X + Y", W / 2, H - 12);
}

const elimProof = [
  { text: '  X + <span class="hi">X\'Y</span>', rule: 'given expression' },
  { text: '= (X + <span class="hi">X\'</span>)·(X + <span class="hi">Y</span>)', rule: 'distribution of + over ·' },
  { text: '= <span class="hi">1</span>·(X + Y)', rule: 'complement: X + X\' = 1' },
  { text: '= <span class="result">X + Y</span>', rule: 'identity: 1·A = A  ∎' },
];

// ── Proof engine (shared) ──
const proofs = [absorbProof, elimProof];
const proofIds = ['proofAbsorb', 'proofElim'];
const currentSteps = [0, 0];

function buildProofs() {
  proofs.forEach((steps, pi) => {
    let html = '';
    steps.forEach((s, i) => {
      html += '<div class="step" id="p' + pi + 's' + i + '">' + s.text +
        '  <span class="rule">[' + s.rule + ']</span></div>';
    });
    document.getElementById(proofIds[pi]).innerHTML = html;
    document.getElementById('p' + pi + 's0').classList.add('visible');
    currentSteps[pi] = 0;
  });
}

function nextStep(pi) {
  if (currentSteps[pi] < proofs[pi].length - 1) {
    currentSteps[pi]++;
    document.getElementById('p' + pi + 's' + currentSteps[pi]).classList.add('visible');
  }
}
function showAllSteps(pi) {
  for (let i = 0; i < proofs[pi].length; i++)
    document.getElementById('p' + pi + 's' + i).classList.add('visible');
  currentSteps[pi] = proofs[pi].length - 1;
}
function resetSteps(pi) {
  for (let i = 1; i < proofs[pi].length; i++)
    document.getElementById('p' + pi + 's' + i).classList.remove('visible');
  currentSteps[pi] = 0;
}

// ── Init ──
buildTTAbsorb();
drawKmapAbsorb();
drawVennAbsorb();
buildTTElim();
drawKmapElim();
drawVennElim();
buildProofs();
</script>
</body>
</html>
