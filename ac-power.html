<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AC Power Analysis</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{font-size:1.5em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.92em;text-align:center;max-width:820px}

  .main{max-width:1060px;width:100%;margin-top:8px}
  .row{display:flex;gap:14px;flex-wrap:wrap;justify-content:center}
  .panel{background:#161b22;border-radius:12px;padding:16px;border:1px solid #30363d;margin-bottom:12px;flex:1;min-width:300px}
  .panel-full{flex-basis:100%}
  .panel h2{font-size:.9em;color:#8b949e;margin-bottom:8px;text-align:center}
  canvas{display:block;margin:0 auto;border-radius:8px}

  .controls{display:flex;gap:14px;flex-wrap:wrap;justify-content:center;align-items:center;
    background:#161b22;border:1px solid #30363d;border-radius:10px;padding:10px 16px;
    margin-bottom:10px;max-width:960px;width:100%}
  .cg{display:flex;align-items:center;gap:6px}
  .cg label{font-size:.82em;color:#8b949e;white-space:nowrap}
  input[type="range"]{width:90px;accent-color:#58a6ff}
  .cv{font-size:.82em;color:#58a6ff;min-width:55px;font-family:'Courier New',monospace}

  .results{background:#161b22;border:1px solid #30363d;border-radius:10px;padding:14px 18px;
    margin-bottom:12px;max-width:960px;width:100%}
  .results h2{font-size:.9em;color:#8b949e;margin-bottom:8px;text-align:center}
  .res-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:8px}
  .res-item{background:#0d1117;border-radius:8px;padding:8px 12px;text-align:center}
  .res-label{font-size:.72em;color:#7d8590;margin-bottom:2px}
  .res-val{font-size:1.05em;font-family:'Courier New',monospace;font-weight:bold}

  .formula-box{background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:10px 14px;
    margin-top:8px;font-size:.82em;color:#8b949e;line-height:1.7;text-align:center}
  .formula-box .f{color:#f78166;font-family:'Courier New',monospace}
  .formula-box .h{color:#e0e0ff;font-weight:bold}

  .info{max-width:960px;width:100%;background:#161b22;border-radius:12px;
    padding:14px 18px;border:1px solid #30363d;margin-top:10px;font-size:.84em;line-height:1.6;color:#8b949e}
  .info strong{color:#e0e0ff}
  a{color:#58a6ff}
</style>
</head>
<body>

<h1>AC Power Analysis</h1>
<p class="subtitle">Average (real) power, reactive power, apparent power, and power factor for an RLC load</p>

<div class="controls">
  <div class="cg">
    <label>V<sub>rms</sub>:</label>
    <input type="range" id="sV" min="10" max="240" step="5" value="120">
    <span class="cv" id="sVV">120 V</span>
  </div>
  <div class="cg">
    <label>Freq:</label>
    <input type="range" id="sF" min="0" max="500" step="1" value="60">
    <span class="cv" id="sFV">60 Hz</span>
  </div>
  <div class="cg">
    <label>R:</label>
    <input type="range" id="sR" min="1" max="100" step="1" value="30">
    <span class="cv" id="sRV">30 Ω</span>
  </div>
  <div class="cg">
    <label>L:</label>
    <input type="range" id="sL" min="0" max="500" step="5" value="80">
    <span class="cv" id="sLV">80 mH</span>
  </div>
  <div class="cg">
    <label>C:</label>
    <input type="range" id="sC" min="0" max="500" step="5" value="0">
    <span class="cv" id="sCV">0 μF</span>
  </div>
</div>

<div class="results">
  <h2>Power Results</h2>
  <div class="res-grid" id="resGrid"></div>
  <div class="formula-box" id="formulaBox"></div>
</div>

<div class="main">
  <div class="row">
    <div class="panel" style="min-width:380px;max-width:440px">
      <h2>Power Triangle</h2>
      <canvas id="triCanvas" width="400" height="340"></canvas>
    </div>
    <div class="panel" style="min-width:300px;max-width:360px">
      <h2>Phasor Diagram</h2>
      <canvas id="phasCanvas" width="320" height="340"></canvas>
    </div>
  </div>
  <div class="row">
    <div class="panel panel-full">
      <h2 style="display:flex;align-items:center;gap:12px">Waveforms — v(t), i(t), and instantaneous power p(t) <button id="btnPause" onclick="togglePause()" style="font-size:.75em;padding:3px 14px;border-radius:6px;border:1px solid #444;background:#21262d;color:#e6edf3;cursor:pointer">Pause</button></h2>
      <canvas id="waveCanvas" width="1000" height="300"></canvas>
    </div>
  </div>
</div>

<div class="info">
  <strong>Average (Real) Power:</strong> P = V<sub>rms</sub>·I<sub>rms</sub>·cos θ &nbsp;(Watts) — actual energy consumed.<br>
  <strong>Reactive Power:</strong> Q = V<sub>rms</sub>·I<sub>rms</sub>·sin θ &nbsp;(VAR) — energy oscillating between source and load.<br>
  <strong>Apparent Power:</strong> S = V<sub>rms</sub>·I<sub>rms</sub> = √(P² + Q²) &nbsp;(VA) — total power capacity required.<br>
  <strong>Power Factor:</strong> PF = cos θ = P / S — fraction of apparent power doing useful work. Leading (capacitive) or lagging (inductive).<br>
  <strong>Try:</strong> Set L=0, C=0 for purely resistive (PF=1) · Increase L for lagging PF · Add C to correct power factor toward 1.<br><br>
  <a href="index.html">← All Demos</a> ·
  <a href="3phase-ac.html">3-Phase AC Power</a> ·
  <a href="phasor-transform.html">Phasor Transform</a> ·
  <a href="dot-convention.html">Dot Convention</a>
</div>

<script>
const sqrt2 = Math.sqrt(2);
const PI = Math.PI;

// Canvases
const triC = document.getElementById('triCanvas');
const phasC = document.getElementById('phasCanvas');
const waveC = document.getElementById('waveCanvas');
const tCtx = triC.getContext('2d');
const pCtx = phasC.getContext('2d');
const wCtx = waveC.getContext('2d');

// Sliders
const defs = [
  ['sV','sVV', v => v + ' V'],
  ['sF','sFV', v => v + ' Hz'],
  ['sR','sRV', v => v + ' Ω'],
  ['sL','sLV', v => v + ' mH'],
  ['sC','sCV', v => v + ' μF'],
];
defs.forEach(([id, vid, fmt]) => {
  document.getElementById(id).oninput = function() {
    document.getElementById(vid).textContent = fmt(this.value);
    compute();
  };
});

let res = {};
let time = 0, lastTS = 0;

function fmt(v) { return Math.abs(v) < 10 ? v.toFixed(2) : Math.abs(v) < 100 ? v.toFixed(1) : Math.round(v); }

function compute() {
  const Vrms = +document.getElementById('sV').value;
  const f = +document.getElementById('sF').value;
  const R = +document.getElementById('sR').value;
  const Lmh = +document.getElementById('sL').value;
  const Cuf = +document.getElementById('sC').value;
  const L = Lmh / 1000;
  const C = Cuf / 1e6;
  const w = 2 * PI * f;

  const XL = w * L;
  const XC = (C > 0 && w > 0) ? 1 / (w * C) : (C > 0 ? Infinity : 0);
  const X = XL - XC;
  const Zmag = Math.sqrt(R * R + X * X);
  const theta = Math.atan2(X, R);

  const Irms = isFinite(Zmag) && Zmag > 0 ? Vrms / Zmag : (f === 0 && C > 0 ? 0 : Vrms / R);
  const Vm = Vrms * sqrt2;
  const Im = Irms * sqrt2;

  const P = Vrms * Irms * Math.cos(theta);  // average (real) power
  const Q = Vrms * Irms * Math.sin(theta);  // reactive power
  const S = Vrms * Irms;                     // apparent power
  const PF = Math.cos(theta);                // power factor

  let loadType;
  if (f === 0) loadType = C > 0 ? 'DC (cap blocks)' : 'DC (resistive)';
  else if (!isFinite(X)) loadType = 'Capacitive (∞ at DC)';
  else if (Math.abs(X) < 0.01) loadType = 'Resistive';
  else loadType = X > 0 ? 'Inductive (lagging)' : 'Capacitive (leading)';

  res = { Vrms, Irms, Vm, Im, f, w, R, XL, XC, X, Zmag, theta, P, Q, S, PF, L, C, loadType };

  updateResults();
  drawPowerTriangle();
}

function updateResults() {
  const r = res;
  const thetaDeg = (r.theta * 180 / PI).toFixed(1);
  const items = [
    {label: 'P (Average Power)', val: fmt(r.P) + ' W', color: '#3fb950'},
    {label: 'Q (Reactive Power)', val: fmt(r.Q) + ' VAR', color: '#f78166'},
    {label: 'S (Apparent Power)', val: fmt(r.S) + ' VA', color: '#58a6ff'},
    {label: 'Power Factor (cos θ)', val: r.PF.toFixed(3), color: '#d2a8ff'},
    {label: 'θ (impedance angle)', val: thetaDeg + '°', color: '#d2a8ff'},
    {label: 'Load Type', val: r.loadType, color: '#8b949e'},
    {label: '|Z|', val: fmt(r.Zmag) + ' Ω', color: '#8b949e'},
    {label: 'I_rms', val: fmt(r.Irms) + ' A', color: '#f97583'},
    {label: 'X_L', val: fmt(r.XL) + ' Ω', color: '#f78166'},
    {label: 'X_C', val: isFinite(r.XC) ? fmt(r.XC) + ' Ω' : '∞ (DC)', color: '#79c0ff'},
    {label: 'X (net reactive)', val: isFinite(r.X) ? fmt(r.X) + ' Ω' : (r.X === -Infinity ? '−∞' : '∞'), color: '#f78166'},
  ];
  let html = '';
  items.forEach(it => {
    html += '<div class="res-item"><div class="res-label">' + it.label + '</div>' +
      '<div class="res-val" style="color:' + it.color + '">' + it.val + '</div></div>';
  });
  document.getElementById('resGrid').innerHTML = html;

  // Formulas
  let f = '<span class="h">Reactance:</span> ';
  const Lmh = res.L * 1000, Cuf = res.C * 1e6;
  f += '<span class="f">X<sub>L</sub> = ωL = 2π·f·L = 2π × ' + res.f + ' × ' + Lmh + ' mH = 2π × ' + res.f + ' × ' + (res.L < 0.01 ? res.L.toFixed(4) : res.L.toFixed(3)) + ' = ' + fmt(res.XL) + ' Ω</span><br>';
  if (Cuf > 0) {
    if (res.f > 0) {
      f += '<span class="f">X<sub>C</sub> = 1/(ωC) = 1/(2π·f·C) = 1/(2π × ' + res.f + ' × ' + Cuf + ' μF) = 1/(2π × ' + res.f + ' × ' + (res.C < 0.0001 ? res.C.toExponential(2) : res.C.toFixed(6)) + ') = ' + fmt(res.XC) + ' Ω</span><br>';
    } else {
      f += '<span class="f">X<sub>C</sub> = 1/(ωC) = 1/(2π × 0 × ' + Cuf + ' μF) = ∞ (DC)</span><br>';
    }
  } else {
    f += '<span class="f">X<sub>C</sub> = 1/(ωC) = 0 Ω &nbsp;(no capacitor)</span><br>';
  }
  f += '<br><span class="h">Impedance:</span> ';
  const xcStr = isFinite(res.XC) ? fmt(res.XC) : '∞';
  const xStr = isFinite(res.X) ? fmt(res.X) : (res.X === -Infinity ? '−∞' : '∞');
  f += '<span class="f">Z = R + j(X<sub>L</sub>−X<sub>C</sub>) = ' + fmt(res.R) + ' + j(' + fmt(res.XL) + '−' + xcStr + ') = ' + fmt(res.R) + (isFinite(res.X) ? (res.X >= 0 ? '+' : '') + 'j' + fmt(res.X) : '+j(−∞)') + ' Ω</span>';
  if (res.f === 0) f += ' <span style="color:#d29922">(DC — capacitor blocks current)</span>';
  f += '<br>';
  f += '<span class="h">Angle:</span> ';
  const xVal = isFinite(res.X) ? fmt(res.X) : (res.X === -Infinity ? '−∞' : '∞');
  f += '<span class="f">θ = arctan(X / R) = arctan(' + xVal + ' / ' + fmt(res.R) + ') = ' + (res.theta * 180 / PI).toFixed(1) + '°</span>';
  f += ' &nbsp;→&nbsp; <span class="f">PF = cos(' + (res.theta * 180 / PI).toFixed(1) + '°) = ' + res.PF.toFixed(3) + '</span>';
  if (res.loadType !== 'Resistive' && res.f > 0) f += ' <span style="color:#d2a8ff">(' + (res.X > 0 ? 'lagging' : 'leading') + ')</span>';
  f += '<br>';
  f += '<span class="h">Power:</span> ';
  f += '<span class="f">P = V·I·cos θ = ' + fmt(res.Vrms) + '×' + fmt(res.Irms) + '×cos(' + (res.theta*180/PI).toFixed(1) + '°) = ' + fmt(res.P) + ' W</span><br>';
  f += '<span class="f">Q = V·I·sin θ = ' + fmt(res.Vrms) + '×' + fmt(res.Irms) + '×sin(' + (res.theta*180/PI).toFixed(1) + '°) = ' + fmt(res.Q) + ' VAR</span><br>';
  f += '<span class="f">S = V·I = ' + fmt(res.Vrms) + '×' + fmt(res.Irms) + ' = ' + fmt(res.S) + ' VA</span> &nbsp;|&nbsp; ';
  f += '<span class="f">PF = cos θ = ' + res.PF.toFixed(3) + '</span>';
  document.getElementById('formulaBox').innerHTML = f;
}

// ── Power Triangle ──
function drawPowerTriangle() {
  const W = triC.width, H = triC.height;
  const ctx = tCtx;
  ctx.clearRect(0, 0, W, H);

  const r = res;
  const cx = 60, cy = H / 2;
  const maxDim = Math.min(W - 100, H - 80);

  // Scale triangle to fit
  const maxPQ = Math.max(Math.abs(r.P), Math.abs(r.Q), r.S, 1);
  const scale = (maxDim * 0.7) / maxPQ;

  const pLen = r.P * scale;
  const qLen = r.Q * scale; // positive = down (inductive), negative = up (capacitive)
  const sLen = r.S * scale;

  // Triangle vertices
  const ox = cx, oy = cy;
  const px = ox + pLen, py = oy;          // P endpoint (horizontal)
  const sx = px, sy = oy + qLen;          // S endpoint = Q endpoint (vertical from P end)

  // ── Draw filled triangle ──
  ctx.globalAlpha = 0.1;
  ctx.fillStyle = '#58a6ff';
  ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(px, py); ctx.lineTo(sx, sy); ctx.closePath(); ctx.fill();
  ctx.globalAlpha = 1;

  // ── P line (horizontal, green) ──
  ctx.strokeStyle = '#3fb950'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(px, py); ctx.stroke();
  // Arrow
  drawTriArrow(ctx, ox, oy, px, py, '#3fb950');

  // ── Q line (vertical, orange) ──
  if (Math.abs(qLen) > 2) {
    ctx.strokeStyle = '#f78166'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(sx, sy); ctx.stroke();
    drawTriArrow(ctx, px, py, sx, sy, '#f78166');
  }

  // ── S line (hypotenuse, blue) ──
  ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 3;
  ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(sx, sy); ctx.stroke();
  drawTriArrow(ctx, ox, oy, sx, sy, '#58a6ff');

  // ── Right angle marker ──
  if (Math.abs(qLen) > 8) {
    const sz = 10;
    const qdir = qLen > 0 ? 1 : -1;
    ctx.strokeStyle = '#484f58'; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(px - sz, py); ctx.lineTo(px - sz, py + sz * qdir); ctx.lineTo(px, py + sz * qdir);
    ctx.stroke();
  }

  // ── Angle arc θ ──
  if (Math.abs(r.theta) > 0.02) {
    const arcR = Math.min(40, pLen * 0.4);
    ctx.strokeStyle = '#d2a8ff'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    if (r.theta > 0) {
      ctx.arc(ox, oy, arcR, 0, r.theta);
    } else {
      ctx.arc(ox, oy, arcR, r.theta, 0);
    }
    ctx.stroke();
    // θ label
    const amid = r.theta / 2;
    ctx.fillStyle = '#d2a8ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('θ=' + (r.theta * 180 / PI).toFixed(1) + '°', ox + Math.cos(amid) * (arcR + 22), oy + Math.sin(amid) * (arcR + 22) + 4);
  }

  // ── Labels ──
  // P label
  ctx.fillStyle = '#3fb950'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
  const plabelY = qLen >= 0 ? oy - 16 : oy + 22;
  ctx.fillText('P = ' + fmt(r.P) + ' W', (ox + px) / 2, plabelY);

  // Q label
  if (Math.abs(qLen) > 8) {
    ctx.fillStyle = '#f78166'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'left';
    ctx.fillText('Q = ' + fmt(r.Q) + ' VAR', px + 10, (py + sy) / 2 + 5);
  }

  // S label
  const smx = (ox + sx) / 2, smy = (oy + sy) / 2;
  const sAng = Math.atan2(sy - oy, sx - ox);
  ctx.save();
  ctx.translate(smx, smy);
  ctx.rotate(sAng);
  ctx.fillStyle = '#58a6ff'; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('S = ' + fmt(r.S) + ' VA', 0, -10);
  ctx.restore();

  // ── Power Factor badge ──
  const bx = W - 80, by = 30;
  ctx.fillStyle = '#21262d';
  ctx.beginPath();
  roundRect(ctx, bx - 50, by - 16, 100, 50, 8);
  ctx.fill();
  ctx.strokeStyle = '#30363d'; ctx.lineWidth = 1; ctx.stroke();
  ctx.fillStyle = '#d2a8ff'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Power Factor', bx, by);
  ctx.font = 'bold 18px monospace';
  const pfColor = r.PF > 0.9 ? '#3fb950' : r.PF > 0.7 ? '#d29922' : '#f97583';
  ctx.fillStyle = pfColor;
  ctx.fillText(r.PF.toFixed(3), bx, by + 22);

  // ── Legend ──
  ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
  const ly = H - 14;
  ctx.fillStyle = '#3fb950'; ctx.fillText('■ P (Real)', 10, ly);
  ctx.fillStyle = '#f78166'; ctx.fillText('■ Q (Reactive)', 100, ly);
  ctx.fillStyle = '#58a6ff'; ctx.fillText('■ S (Apparent)', 215, ly);
  ctx.fillStyle = '#8b949e'; ctx.fillText('Q>0: inductive ↓  Q<0: capacitive ↑', 10, ly - 16);
}

function drawTriArrow(ctx, x1, y1, x2, y2, color) {
  const ang = Math.atan2(y2 - y1, x2 - x1);
  const hl = 8;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - hl * Math.cos(ang - 0.3), y2 - hl * Math.sin(ang - 0.3));
  ctx.lineTo(x2 - hl * Math.cos(ang + 0.3), y2 - hl * Math.sin(ang + 0.3));
  ctx.closePath(); ctx.fill();
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
  ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
  ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
  ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y);
  ctx.closePath();
}

// ── Phasor Diagram ──
function drawPhasors() {
  const W = phasC.width, H = phasC.height;
  const ctx = pCtx;
  ctx.clearRect(0, 0, W, H);
  const cx = W / 2, cy = H / 2;
  const maxR = Math.min(W, H) / 2 - 30;

  // Grid
  ctx.strokeStyle = '#ffffff08'; ctx.lineWidth = 1;
  for (let r = maxR / 3; r <= maxR; r += maxR / 3) {
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, PI * 2); ctx.stroke();
  }
  ctx.strokeStyle = '#ffffff15';
  ctx.beginPath(); ctx.moveTo(10, cy); ctx.lineTo(W - 10, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 10); ctx.lineTo(cx, H - 10); ctx.stroke();

  const r = res;
  const baseAngle = time * r.w;

  // V phasor (reference at baseAngle)
  const vLen = maxR * 0.8;
  const vAng = baseAngle;
  drawPhasorArrow(ctx, cx, cy, vAng, vLen, '#58a6ff', 2.5, 'V');

  // I phasor (lagging by θ)
  const iLen = maxR * 0.55;
  const iAng = baseAngle - r.theta;
  drawPhasorArrow(ctx, cx, cy, iAng, iLen, '#f97583', 2, 'I');

  // Angle arc
  if (Math.abs(r.theta) > 0.02) {
    const arcR = 30;
    ctx.strokeStyle = '#d2a8ff60'; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(cx, cy, arcR, -vAng, -iAng, r.theta > 0);
    ctx.stroke();
    const am = (vAng + iAng) / 2;
    ctx.fillStyle = '#d2a8ff'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('θ', cx + Math.cos(am) * (arcR + 12), cy - Math.sin(am) * (arcR + 12) + 3);
  }

  // Legend
  ctx.font = '10px sans-serif'; ctx.textAlign = 'left';
  ctx.fillStyle = '#58a6ff'; ctx.fillText('— V (voltage)', 8, H - 22);
  ctx.fillStyle = '#f97583'; ctx.fillText('— I (current)', 8, H - 8);
  ctx.fillStyle = '#8b949e'; ctx.textAlign = 'right';
  ctx.fillText(r.loadType, W - 8, H - 8);
}

function drawPhasorArrow(ctx, cx, cy, angle, length, color, width, label) {
  const ex = cx + Math.cos(angle) * length;
  const ey = cy - Math.sin(angle) * length;
  ctx.strokeStyle = color; ctx.lineWidth = width;
  ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ex, ey); ctx.stroke();
  const hl = 8;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(ex, ey);
  ctx.lineTo(ex - hl * Math.cos(angle - 0.3), ey + hl * Math.sin(angle - 0.3));
  ctx.lineTo(ex - hl * Math.cos(angle + 0.3), ey + hl * Math.sin(angle + 0.3));
  ctx.closePath(); ctx.fill();
  const lx = cx + Math.cos(angle) * (length + 14);
  const ly = cy - Math.sin(angle) * (length + 14);
  ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(label, lx, ly + 4);
}

// ── Waveforms ──
function drawWaveforms() {
  const W = waveC.width, H = waveC.height;
  const ctx = wCtx;
  ctx.clearRect(0, 0, W, H);

  const r = res;
  const plotL = 60, plotR = W - 20;
  const plotW = plotR - plotL;
  const midY = H / 2;
  const topY = 20, botY = H - 20;

  // Grid
  ctx.strokeStyle = '#ffffff08'; ctx.lineWidth = 1;
  for (let y = topY; y <= botY; y += (botY - topY) / 6) {
    ctx.beginPath(); ctx.moveTo(plotL, y); ctx.lineTo(plotR, y); ctx.stroke();
  }
  ctx.strokeStyle = '#ffffff20';
  ctx.beginPath(); ctx.moveTo(plotL, midY); ctx.lineTo(plotR, midY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(plotL, topY); ctx.lineTo(plotL, botY); ctx.stroke();

  // Axis labels
  ctx.fillStyle = '#484f58'; ctx.font = '10px sans-serif'; ctx.textAlign = 'right';
  ctx.fillText('+', plotL - 4, topY + 6);
  ctx.fillText('0', plotL - 4, midY + 3);
  ctx.fillText('−', plotL - 4, botY - 2);

  const freq = r.f;
  const cycles = 2;
  const halfH = (H / 2 - 25);
  const Vm = r.Vm, Im = r.Im;

  // Handle DC (freq=0): show flat lines
  if (freq <= 0) {
    // DC: v = Vm (constant), i = Im (constant), p = Vm*Im (constant)
    const dcP = Vm * Im;
    // v(t) line
    const vY = midY - halfH * 0.5;
    ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(plotL, vY); ctx.lineTo(plotR, vY); ctx.stroke();
    ctx.fillStyle = '#58a6ff'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'left';
    ctx.fillText('v = ' + fmt(Vm) + ' V (DC)', plotL + 10, vY - 8);
    // i(t) line
    const iY = midY - halfH * 0.25;
    ctx.strokeStyle = '#f97583'; ctx.lineWidth = 2; ctx.setLineDash([5, 4]);
    ctx.beginPath(); ctx.moveTo(plotL, iY); ctx.lineTo(plotR, iY); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#f97583'; ctx.font = 'bold 10px sans-serif';
    ctx.fillText('i = ' + fmt(Im) + ' A (DC)', plotL + 10, iY - 8);
    // p(t) line = P_avg
    if (dcP > 0) {
      const pY = midY - halfH * 0.7;
      ctx.strokeStyle = '#d29922'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(plotL, pY); ctx.lineTo(plotR, pY); ctx.stroke();
      ctx.fillStyle = '#d29922'; ctx.font = 'bold 10px sans-serif';
      ctx.fillText('p = P_avg = ' + fmt(r.P) + ' W', plotL + 10, pY - 8);
      ctx.fillStyle = '#3fb95018';
      ctx.fillRect(plotL, pY, plotW, midY - pY);
    }
  } else {
    // ── Compute global max for p(t) scaling ──
    // p(t) = (Vm·Im/2)[cosθ − cos(2ωt−θ)], peak = (Vm·Im/2)(1+|cosθ|)
    const maxP = Math.max(Vm * Im, 1);
    const pScale = halfH * 0.8 / maxP;

    // ── p(t) fill — green when p>0, red when p<0 ──
    for (let i = 0; i < plotW; i++) {
      const t = (i / plotW) * cycles / freq + time;
      const v = Vm * Math.sin(2 * PI * freq * t);
      const ic = Im * Math.sin(2 * PI * freq * t - r.theta);
      const p = v * ic;
      const py = midY - p * pScale;
      const x = plotL + i;
      if (p > 0) {
        ctx.fillStyle = '#3fb95018';
        ctx.fillRect(x, py, 1, midY - py);
      } else {
        ctx.fillStyle = '#f9758318';
        ctx.fillRect(x, midY, 1, py - midY);
      }
    }

    // ── p(t) line ──
    ctx.strokeStyle = '#d29922'; ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= plotW; i++) {
      const t = (i / plotW) * cycles / freq + time;
      const v = Vm * Math.sin(2 * PI * freq * t);
      const ic = Im * Math.sin(2 * PI * freq * t - r.theta);
      const p = v * ic;
      const x = plotL + i;
      const y = midY - p * pScale;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // ── Average power line P ──
    const pAvgY = midY - r.P * pScale;
    ctx.strokeStyle = '#3fb950'; ctx.lineWidth = 1.5; ctx.setLineDash([6, 4]);
    ctx.beginPath(); ctx.moveTo(plotL, pAvgY); ctx.lineTo(plotR, pAvgY); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#3fb950'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'left';
    ctx.fillText('P_avg = ' + fmt(r.P) + ' W', plotR - 130, pAvgY - 6);

    // ── v(t) line ──
    const vScale = halfH * 0.6 / Math.max(Vm, 1);
    ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= plotW; i++) {
      const t = (i / plotW) * cycles / freq + time;
      const v = Vm * Math.sin(2 * PI * freq * t);
      const x = plotL + i;
      const y = midY - v * vScale;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // ── i(t) line ──
    const iScale = halfH * 0.6 / Math.max(Im, 0.01);
    ctx.strokeStyle = '#f97583'; ctx.lineWidth = 2; ctx.setLineDash([5, 4]);
    ctx.beginPath();
    for (let i = 0; i <= plotW; i++) {
      const t = (i / plotW) * cycles / freq + time;
      const ic = Im * Math.sin(2 * PI * freq * t - r.theta);
      const x = plotL + i;
      const y = midY - ic * iScale;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Legend
  ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'left';
  ctx.fillStyle = '#58a6ff'; ctx.fillText('— v(t)', plotL + 10, 14);
  ctx.fillStyle = '#f97583'; ctx.fillText('--- i(t)', plotL + 70, 14);
  ctx.fillStyle = '#d29922'; ctx.fillText('— p(t)', plotL + 140, 14);
  ctx.fillStyle = '#3fb950'; ctx.fillText('--- P_avg', plotL + 210, 14);
  ctx.fillStyle = '#3fb95040'; ctx.fillRect(plotL + 290, 6, 10, 10);
  ctx.fillStyle = '#8b949e'; ctx.fillText('p>0', plotL + 305, 14);
  ctx.fillStyle = '#f9758340'; ctx.fillRect(plotL + 340, 6, 10, 10);
  ctx.fillStyle = '#8b949e'; ctx.fillText('p<0 (returned)', plotL + 355, 14);
}

// ── Animation ──
let paused = false;
function togglePause() {
  paused = !paused;
  document.getElementById('btnPause').textContent = paused ? 'Play' : 'Pause';
  if (!paused) { lastTS = 0; requestAnimationFrame(animate); }
}
function animate(ts) {
  if (paused) return;
  if (!lastTS) lastTS = ts;
  const dt = Math.min((ts - lastTS) / 1000, 0.05);
  lastTS = ts;
  time += dt * 0.15;
  drawPhasors();
  drawWaveforms();
  requestAnimationFrame(animate);
}

compute();
requestAnimationFrame(animate);
</script>
</body>
</html>
