<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sawtooth Pulse on a Transmission Line</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{font-size:1.5em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.92em;text-align:center;max-width:820px}
  canvas{display:block;border-radius:10px}
  .row{display:flex;flex-wrap:wrap;gap:12px;justify-content:center;margin-top:10px;max-width:1160px;width:100%}
  .panel{background:#161b22;border-radius:12px;padding:12px;border:1px solid #30363d;flex:1;min-width:260px}
  .panel h2{font-size:.88em;color:#8b949e;margin-bottom:4px;text-align:center}
  .wide{flex:2;min-width:540px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;justify-content:center;align-items:center}
  .cg{display:flex;align-items:center;gap:4px}
  .cg label{font-size:.78em;color:#8b949e;white-space:nowrap}
  input[type="range"]{width:90px;accent-color:#f78166}
  .val{font-size:.78em;color:#f78166;min-width:30px}
  button{background:#238636;color:white;border:none;padding:6px 14px;border-radius:6px;
    cursor:pointer;font-size:.82em;transition:.2s}
  button:hover{background:#2ea043}
  button.sec{background:#30363d}
  button.sec:hover{background:#484f58}
  .presets{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:8px}
  .preset{padding:4px 12px;border-radius:6px;cursor:pointer;font-size:.76em;
    background:#21262d;border:1px solid #30363d;color:#8b949e;transition:.2s}
  .preset:hover{border-color:#58a6ff;color:#e6edf3}
  .preset.active{background:#1f6feb;border-color:#1f6feb;color:white}
  .meters{display:flex;gap:8px;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .meter{background:#161b22;border:1px solid #30363d;border-radius:8px;padding:4px 10px;text-align:center;min-width:90px}
  .meter .ml{font-size:.68em;color:#8b949e}
  .meter .mv{font-size:.88em;font-weight:bold;font-family:'Courier New',monospace}
  .legend{display:flex;gap:12px;justify-content:center;margin:6px 0;flex-wrap:wrap}
  .legend-item{display:flex;align-items:center;gap:4px;font-size:.76em}
  .legend-dot{width:9px;height:9px;border-radius:50%}
  .info{max-width:1160px;width:100%;background:#161b22;border-radius:12px;
    padding:14px 18px;border:1px solid #30363d;margin-top:14px;font-size:.84em;line-height:1.6;color:#8b949e}
  .info strong{color:#e0e0ff}
  .info code{color:#f78166;background:#21262d;padding:1px 4px;border-radius:3px}
  a{color:#58a6ff}
  .eq-box{background:#161b22;border:1px solid #30363d;border-radius:10px;
    padding:8px 14px;margin:6px 0;max-width:1160px;width:100%;text-align:center}
  .eq{font-size:1.05em;font-family:'Times New Roman',serif;color:#e0e0ff}
  .eq-desc{font-size:.78em;color:#7d8590;margin-top:2px}
</style>
</head>
<body>

<h1>Single Sawtooth Pulse on a Transmission Line</h1>
<p class="subtitle">A single sawtooth ramp — built from N Fourier harmonics — is launched once and propagates, reflects, disperses, and attenuates along the line</p>

<div class="eq-box">
  <div class="eq">v(t) = Σ<sub>n=1</sub><sup>N</sup> (2V<sub>p</sub> / nπ)(−1)<sup>n+1</sup> sin(nωt) &nbsp;for 0 ≤ t ≤ T, &nbsp;0 elsewhere &nbsp;→&nbsp; each harmonic propagates at v<sub>n</sub>, attenuates, reflects at Γ<sub>L</sub></div>
  <div class="eq-desc">The single pulse is windowed to one period T. Each Fourier component travels independently — watch it spread and distort.</div>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#f78166"></div> Source pulse</div>
  <div class="legend-item"><div class="legend-dot" style="background:#58a6ff"></div> Forward wave</div>
  <div class="legend-item"><div class="legend-dot" style="background:#f0883e"></div> Reflected wave</div>
  <div class="legend-item"><div class="legend-dot" style="background:#e6edf3"></div> Total V(x)</div>
  <div class="legend-item"><div class="legend-dot" style="background:#3fb950"></div> Received at load</div>
  <div class="legend-item"><div class="legend-dot" style="background:#bc8cff"></div> Individual harmonics</div>
</div>

<div class="row">
  <div class="panel">
    <h2>Source Waveform v(t) at x = 0</h2>
    <canvas id="srcCanvas" width="360" height="200"></canvas>
  </div>
  <div class="panel wide">
    <h2>Transmission Line — Spatial Snapshot V(x, t)</h2>
    <canvas id="lineCanvas" width="720" height="200"></canvas>
  </div>
  <div class="panel">
    <h2>Received at Load v(t) at x = L</h2>
    <canvas id="rcvCanvas" width="360" height="200"></canvas>
  </div>
</div>

<div class="row">
  <div class="panel wide">
    <h2>Fourier Harmonics Spectrum</h2>
    <canvas id="specCanvas" width="720" height="180"></canvas>
  </div>
  <div class="panel">
    <h2>Harmonic Decomposition (source pulse)</h2>
    <canvas id="harmCanvas" width="360" height="180"></canvas>
  </div>
</div>

<div class="meters">
  <div class="meter"><div class="ml">Harmonics N</div><div class="mv" id="mN">15</div></div>
  <div class="meter"><div class="ml">Time t</div><div class="mv" id="mTime">0.00</div></div>
  <div class="meter"><div class="ml">Γ<sub>L</sub></div><div class="mv" id="mGamma">0.00</div></div>
  <div class="meter"><div class="ml">Z₀</div><div class="mv" id="mZ0">50 Ω</div></div>
  <div class="meter"><div class="ml">Z<sub>L</sub></div><div class="mv" id="mZL">50 Ω</div></div>
  <div class="meter"><div class="ml">Pulse width T</div><div class="mv" id="mT">1.00</div></div>
  <div class="meter"><div class="ml">α (atten)</div><div class="mv" id="mAlpha">0.0</div></div>
  <div class="meter"><div class="ml">Dispersion</div><div class="mv" id="mDisp">Off</div></div>
</div>

<div class="controls">
  <div class="cg">
    <label>Harmonics N:</label>
    <input type="range" id="slN" min="1" max="50" step="1" value="15">
    <span class="val" id="vN">15</span>
  </div>
  <div class="cg">
    <label>Z₀ (Ω):</label>
    <input type="range" id="slZ0" min="10" max="200" step="5" value="50">
    <span class="val" id="vZ0">50</span>
  </div>
  <div class="cg">
    <label>Z<sub>L</sub> (Ω):</label>
    <input type="range" id="slZL" min="0" max="500" step="5" value="50">
    <span class="val" id="vZL">50</span>
  </div>
  <div class="cg">
    <label>Attenuation:</label>
    <input type="range" id="slAlpha" min="0" max="3" step="0.1" value="0">
    <span class="val" id="vAlpha">0</span>
  </div>
  <div class="cg">
    <label>Dispersion:</label>
    <input type="range" id="slDisp" min="0" max="1" step="0.05" value="0">
    <span class="val" id="vDisp">0</span>
  </div>
  <div class="cg">
    <label>Prop. speed:</label>
    <input type="range" id="slVp" min="0.2" max="2" step="0.05" value="0.8">
    <span class="val" id="vVp">0.80</span>
  </div>
  <div class="cg">
    <label>Sim speed:</label>
    <input type="range" id="slSpeed" min="0.1" max="3" step="0.1" value="1">
    <span class="val" id="vSpeed">1.0</span>
  </div>
  <button id="btnPause">Pause</button>
  <button id="btnReset" class="sec">Restart</button>
</div>

<div class="presets">
  <div class="preset active" data-p="matched">Matched Load</div>
  <div class="preset" data-p="open">Open End</div>
  <div class="preset" data-p="short">Short Circuit</div>
  <div class="preset" data-p="lossy">Lossy Line</div>
  <div class="preset" data-p="dispersive">Dispersive</div>
  <div class="preset" data-p="lossy-dispersive">Lossy + Dispersive</div>
  <div class="preset" data-p="single">Single Harmonic</div>
  <div class="preset" data-p="many">50 Harmonics (sharp)</div>
</div>

<div class="info">
  <strong>How It Works:</strong>
  A single sawtooth ramp is synthesized from N Fourier harmonics over one period T, then the source goes silent.
  Each harmonic <code>aₙ sin(nωτ)</code> propagates independently along the line at its own phase velocity.
  <br><br>
  <strong>Attenuation</strong> (α ∝ √n) decays higher harmonics faster, rounding the sharp ramp edge.
  <strong>Dispersion</strong> makes each harmonic travel at a different speed, spreading the pulse in space and time.
  At the <strong>load</strong>, each harmonic reflects with Γ<sub>L</sub> = (Z<sub>L</sub>−Z₀)/(Z<sub>L</sub>+Z₀):
  open end (+1) reflects in-phase, short (−1) inverts, matched (0) absorbs fully.
  <br><br>
  Try "Open End" or "Short Circuit" to see the reflected pulse bounce back toward the source.
  <br><br>
  <a href="index.html">← 3-Phase AC</a> ·
  <a href="mutual-inductance.html">Mutual Inductance</a> ·
  <a href="bounce-diagram.html">Bounce Diagram</a> ·
  <a href="transformer.html">Transformer</a> ·
  <a href="maxwell.html">Maxwell's Equations</a> ·
  <a href="poynting.html">Poynting Theorem</a> ·
  <a href="vectors.html">Dot &amp; Cross Product</a> ·
  <a href="phasor-transform.html">Phasor Transform</a> ·
  <a href="kmap.html">K-Map Simplifier</a>
</div>

<script>
// ── Canvases ──
const srcCvs = document.getElementById('srcCanvas');
const lineCvs = document.getElementById('lineCanvas');
const rcvCvs = document.getElementById('rcvCanvas');
const specCvs = document.getElementById('specCanvas');
const harmCvs = document.getElementById('harmCanvas');
const srcCtx = srcCvs.getContext('2d');
const lineCtx = lineCvs.getContext('2d');
const rcvCtx = rcvCvs.getContext('2d');
const specCtx = specCvs.getContext('2d');
const harmCtx = harmCvs.getContext('2d');

// ── Controls ──
const slN = document.getElementById('slN');
const slZ0 = document.getElementById('slZ0');
const slZL = document.getElementById('slZL');
const slAlpha = document.getElementById('slAlpha');
const slDisp = document.getElementById('slDisp');
const slVp = document.getElementById('slVp');
const slSpeed = document.getElementById('slSpeed');

let paused = false;
let time = 0;
let lastTS = 0;

// Line length (normalized to 1), pulse period T = 1
const LINE_LEN = 1;
const T = 1; // pulse duration (one period of sawtooth)
const omega = 2 * Math.PI / T;

// History buffers for received waveform plot
const RCV_HIST_LEN = 400;
let rcvHistory = new Float32Array(RCV_HIST_LEN);
let rcvHistTime = new Float32Array(RCV_HIST_LEN);
let rcvHistIdx = 0;
let rcvHistCount = 0;
let lastRcvSampleTime = -1;

// ── Slider labels ──
function updLabels() {
  document.getElementById('vN').textContent = slN.value;
  document.getElementById('vZ0').textContent = slZ0.value;
  document.getElementById('vZL').textContent = slZL.value;
  document.getElementById('vAlpha').textContent = parseFloat(slAlpha.value).toFixed(1);
  document.getElementById('vDisp').textContent = parseFloat(slDisp.value).toFixed(2);
  document.getElementById('vVp').textContent = parseFloat(slVp.value).toFixed(2);
  document.getElementById('vSpeed').textContent = parseFloat(slSpeed.value).toFixed(1);
}
[slN, slZ0, slZL, slAlpha, slDisp, slVp, slSpeed].forEach(s => s.oninput = updLabels);

// ── Meters ──
function updMeters() {
  const N = +slN.value, Z0 = +slZ0.value, ZL = +slZL.value;
  const alpha = +slAlpha.value, disp = +slDisp.value;
  const gamma = ZL >= 500 ? 1 : ZL === 0 ? -1 : (ZL - Z0) / (ZL + Z0);
  document.getElementById('mN').textContent = N;
  document.getElementById('mTime').textContent = time.toFixed(2);
  document.getElementById('mGamma').textContent = gamma.toFixed(3);
  document.getElementById('mZ0').textContent = Z0 + ' Ω';
  document.getElementById('mZL').textContent = ZL >= 500 ? '∞ (open)' : ZL === 0 ? '0 (short)' : ZL + ' Ω';
  document.getElementById('mT').textContent = T.toFixed(2);
  document.getElementById('mAlpha').textContent = alpha.toFixed(1) + ' dB/m';
  document.getElementById('mDisp').textContent = disp > 0 ? (disp * 100).toFixed(0) + '%' : 'Off';
}

// ── Presets ──
document.querySelectorAll('.preset').forEach(el => {
  el.addEventListener('click', () => {
    document.querySelectorAll('.preset').forEach(e => e.classList.remove('active'));
    el.classList.add('active');
    const p = el.dataset.p;
    switch(p) {
      case 'matched':
        slN.value=15; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slVp.value=0.8;
        break;
      case 'open':
        slN.value=15; slZ0.value=50; slZL.value=500; slAlpha.value=0; slDisp.value=0; slVp.value=0.8;
        break;
      case 'short':
        slN.value=15; slZ0.value=50; slZL.value=0; slAlpha.value=0; slDisp.value=0; slVp.value=0.8;
        break;
      case 'lossy':
        slN.value=25; slZ0.value=50; slZL.value=50; slAlpha.value=1.5; slDisp.value=0; slVp.value=0.8;
        break;
      case 'dispersive':
        slN.value=25; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0.6; slVp.value=0.8;
        break;
      case 'lossy-dispersive':
        slN.value=30; slZ0.value=50; slZL.value=75; slAlpha.value=1.0; slDisp.value=0.4; slVp.value=0.8;
        break;
      case 'single':
        slN.value=1; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slVp.value=0.8;
        break;
      case 'many':
        slN.value=50; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slVp.value=0.8;
        break;
    }
    updLabels();
    resetSim();
  });
});

function resetSim() {
  time = 0;
  rcvHistory.fill(0);
  rcvHistTime.fill(0);
  rcvHistIdx = 0;
  rcvHistCount = 0;
  lastRcvSampleTime = -1;
}

// ── Pause / Reset ──
document.getElementById('btnPause').onclick = () => {
  paused = !paused;
  document.getElementById('btnPause').textContent = paused ? 'Play' : 'Pause';
};
document.getElementById('btnReset').onclick = () => {
  paused = false;
  document.getElementById('btnPause').textContent = 'Pause';
  slN.value=15; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slVp.value=0.8; slSpeed.value=1;
  document.querySelectorAll('.preset').forEach(e => e.classList.remove('active'));
  document.querySelector('[data-p="matched"]').classList.add('active');
  updLabels();
  resetSim();
};

// ── Physics ──
// Fourier coefficient for sawtooth: a_n = (2/(nπ))(-1)^(n+1)
function harmonicCoeff(n) {
  return 2 / (n * Math.PI) * Math.pow(-1, n + 1);
}

// Attenuation: higher harmonics decay faster (skin effect: α ∝ √n)
function attenFactor(n, alpha, dist) {
  if (alpha === 0) return 1;
  return Math.exp(-alpha * Math.sqrt(n) * dist * 0.3);
}

// Phase velocity for harmonic n (dispersion makes higher harmonics slower)
function phaseVelocity(n, vp0, disp) {
  if (disp === 0) return vp0;
  return vp0 / (1 + disp * (n - 1) * 0.08);
}

// Compute the single-pulse sawtooth source at local time tau
// The pulse is active for 0 <= tau <= T, zero elsewhere
function sourcePulse(tau, N) {
  if (tau < 0 || tau > T) return 0;
  let v = 0;
  for (let n = 1; n <= N; n++) {
    v += harmonicCoeff(n) * Math.sin(n * omega * tau);
  }
  return v;
}

// Forward wave at position x, global time t
// Each harmonic n arrives with delay x / v_n
function forwardWave(x, t, N, alpha, disp, vp0) {
  let v = 0;
  for (let n = 1; n <= N; n++) {
    const vn = phaseVelocity(n, vp0, disp);
    const tau = t - x / vn; // retarded time
    if (tau < 0 || tau > T) continue;
    const an = harmonicCoeff(n);
    const atten = attenFactor(n, alpha, x);
    v += an * atten * Math.sin(n * omega * tau);
  }
  return v;
}

// Reflected wave at position x, global time t
// Reflects at x=L, travels backward. Equivalent to a virtual source at x=2L
function reflectedWave(x, t, N, alpha, disp, vp0, gamma) {
  if (Math.abs(gamma) < 0.001) return 0;
  let v = 0;
  for (let n = 1; n <= N; n++) {
    const vn = phaseVelocity(n, vp0, disp);
    const tau = t - (2 * LINE_LEN - x) / vn; // retarded time for reflected path
    if (tau < 0 || tau > T) continue;
    const an = harmonicCoeff(n);
    const dist = 2 * LINE_LEN - x; // total distance traveled
    const atten = attenFactor(n, alpha, dist);
    v += gamma * an * atten * Math.sin(n * omega * tau);
  }
  return v;
}

// Total wave at position x, time t
function totalWave(x, t, N, alpha, disp, vp0, gamma) {
  return forwardWave(x, t, N, alpha, disp, vp0)
       + reflectedWave(x, t, N, alpha, disp, vp0, gamma);
}

// ── Drawing helpers ──
function drawGrid(ctx, W, H, pad) {
  ctx.strokeStyle = '#ffffff08';
  ctx.lineWidth = 1;
  const l = pad.l, r = pad.r, t = pad.t, b = pad.b;
  for (let i = 0; i <= 4; i++) {
    const y = t + (H - t - b) * i / 4;
    ctx.beginPath(); ctx.moveTo(l, y); ctx.lineTo(W - r, y); ctx.stroke();
  }
  for (let i = 0; i <= 8; i++) {
    const x = l + (W - l - r) * i / 8;
    ctx.beginPath(); ctx.moveTo(x, t); ctx.lineTo(x, H - b); ctx.stroke();
  }
}

function drawAxis(ctx, W, H, pad, xLabel, yLabel) {
  const midY = (pad.t + H - pad.b) / 2;
  ctx.strokeStyle = '#ffffff20';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(pad.l, midY); ctx.lineTo(W - pad.r, midY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(pad.l, pad.t); ctx.lineTo(pad.l, H - pad.b); ctx.stroke();
  ctx.fillStyle = '#555';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  if (xLabel) ctx.fillText(xLabel, (pad.l + W - pad.r) / 2, H - 2);
  ctx.textAlign = 'right';
  if (yLabel) ctx.fillText(yLabel, pad.l - 3, pad.t + 8);
}

const HARM_COLORS = [
  '#ff6b6b','#ffa94d','#ffd43b','#69db7c','#38d9a9',
  '#4dabf7','#748ffc','#9775fa','#da77f2','#f783ac'
];

// ── Draw source waveform (v vs t at x=0) ──
function drawSource() {
  const W = srcCvs.width, H = srcCvs.height;
  const N = +slN.value;
  const pad = {l: 30, r: 10, t: 10, b: 16};
  srcCtx.clearRect(0, 0, W, H);
  drawGrid(srcCtx, W, H, pad);
  drawAxis(srcCtx, W, H, pad, 'Time →', 'V');

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 5;
  const tWindow = T * 2.5; // show 2.5x the pulse width

  // Ideal sawtooth shape (thin gray) — one ramp
  srcCtx.strokeStyle = '#ffffff18';
  srcCtx.lineWidth = 1;
  srcCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const tPlot = (i / pW) * tWindow;
    let ideal = 0;
    if (tPlot >= 0 && tPlot <= T) {
      ideal = 2 * (tPlot / T) - 1; // ramp -1 to +1
    }
    const x = pad.l + i;
    const y = midY - ideal * yScale;
    i === 0 ? srcCtx.moveTo(x, y) : srcCtx.lineTo(x, y);
  }
  srcCtx.stroke();

  // Fourier-synthesized single pulse
  srcCtx.strokeStyle = '#f78166';
  srcCtx.lineWidth = 2.5;
  srcCtx.shadowColor = '#f78166';
  srcCtx.shadowBlur = 6;
  srcCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const tPlot = (i / pW) * tWindow;
    const v = sourcePulse(tPlot, N);
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? srcCtx.moveTo(x, y) : srcCtx.lineTo(x, y);
  }
  srcCtx.stroke();
  srcCtx.shadowBlur = 0;

  // Current time marker
  const tFrac = time / tWindow;
  if (tFrac >= 0 && tFrac <= 1) {
    const mx = pad.l + tFrac * pW;
    srcCtx.strokeStyle = '#ffffff50';
    srcCtx.lineWidth = 1;
    srcCtx.setLineDash([3, 3]);
    srcCtx.beginPath(); srcCtx.moveTo(mx, pad.t); srcCtx.lineTo(mx, H - pad.b); srcCtx.stroke();
    srcCtx.setLineDash([]);
    // Dot at current value
    const cv = sourcePulse(time, N);
    srcCtx.beginPath();
    srcCtx.arc(mx, midY - cv * yScale, 4, 0, Math.PI * 2);
    srcCtx.fillStyle = '#f78166';
    srcCtx.fill();
    srcCtx.strokeStyle = '#fff';
    srcCtx.lineWidth = 1;
    srcCtx.stroke();
  }

  // Labels
  srcCtx.fillStyle = '#f78166';
  srcCtx.font = 'bold 10px sans-serif';
  srcCtx.textAlign = 'left';
  srcCtx.fillText('Single Sawtooth Pulse', pad.l + 4, pad.t + 12);
  srcCtx.fillStyle = '#555';
  srcCtx.fillText('N=' + N, pad.l + 140, pad.t + 12);

  // T marker
  const tEndX = pad.l + (T / tWindow) * pW;
  srcCtx.strokeStyle = '#ffffff30';
  srcCtx.lineWidth = 1;
  srcCtx.setLineDash([2, 2]);
  srcCtx.beginPath(); srcCtx.moveTo(tEndX, pad.t); srcCtx.lineTo(tEndX, H - pad.b); srcCtx.stroke();
  srcCtx.setLineDash([]);
  srcCtx.fillStyle = '#888';
  srcCtx.font = '9px sans-serif';
  srcCtx.textAlign = 'center';
  srcCtx.fillText('T', tEndX, H - pad.b + 10);
}

// ── Draw transmission line spatial view ──
function drawLine() {
  const W = lineCvs.width, H = lineCvs.height;
  const N = +slN.value, Z0 = +slZ0.value, ZL = +slZL.value;
  const alpha = +slAlpha.value, disp = +slDisp.value;
  const vp0 = +slVp.value;
  const gamma = ZL >= 500 ? 1 : ZL === 0 ? -1 : (ZL - Z0) / (ZL + Z0);
  const pad = {l: 40, r: 30, t: 12, b: 20};
  lineCtx.clearRect(0, 0, W, H);
  drawGrid(lineCtx, W, H, pad);

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 8;

  // Center axis
  lineCtx.strokeStyle = '#ffffff20';
  lineCtx.lineWidth = 1;
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, midY); lineCtx.lineTo(W - pad.r, midY); lineCtx.stroke();

  // Source and load markers
  lineCtx.strokeStyle = '#f78166';
  lineCtx.lineWidth = 2;
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, pad.t + 8); lineCtx.lineTo(pad.l, H - pad.b - 8); lineCtx.stroke();
  lineCtx.fillStyle = '#f78166';
  lineCtx.font = '9px sans-serif';
  lineCtx.textAlign = 'center';
  lineCtx.fillText('SRC', pad.l, H - pad.b + 10);

  lineCtx.strokeStyle = '#3fb950';
  lineCtx.lineWidth = 2;
  lineCtx.beginPath(); lineCtx.moveTo(W - pad.r, pad.t + 8); lineCtx.lineTo(W - pad.r, H - pad.b - 8); lineCtx.stroke();
  lineCtx.fillStyle = '#3fb950';
  lineCtx.fillText('LOAD', W - pad.r, H - pad.b + 10);

  // Transmission line rails
  lineCtx.strokeStyle = '#ffffff08';
  lineCtx.lineWidth = 1;
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, pad.t + 4); lineCtx.lineTo(W - pad.r, pad.t + 4); lineCtx.stroke();
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, H - pad.b - 4); lineCtx.lineTo(W - pad.r, H - pad.b - 4); lineCtx.stroke();

  // Forward wave (blue)
  lineCtx.strokeStyle = '#58a6ff';
  lineCtx.lineWidth = 1.5;
  lineCtx.globalAlpha = 0.5;
  lineCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const x01 = (i / pW) * LINE_LEN;
    const v = forwardWave(x01, time, N, alpha, disp, vp0);
    const px = pad.l + i;
    const py = midY - v * yScale;
    i === 0 ? lineCtx.moveTo(px, py) : lineCtx.lineTo(px, py);
  }
  lineCtx.stroke();
  lineCtx.globalAlpha = 1;

  // Reflected wave (orange, dashed)
  if (Math.abs(gamma) > 0.01) {
    lineCtx.strokeStyle = '#f0883e';
    lineCtx.lineWidth = 1.5;
    lineCtx.globalAlpha = 0.5;
    lineCtx.setLineDash([4, 3]);
    lineCtx.beginPath();
    for (let i = 0; i <= pW; i++) {
      const x01 = (i / pW) * LINE_LEN;
      const v = reflectedWave(x01, time, N, alpha, disp, vp0, gamma);
      const px = pad.l + i;
      const py = midY - v * yScale;
      i === 0 ? lineCtx.moveTo(px, py) : lineCtx.lineTo(px, py);
    }
    lineCtx.stroke();
    lineCtx.setLineDash([]);
    lineCtx.globalAlpha = 1;
  }

  // Total wave (bright white)
  lineCtx.strokeStyle = '#e6edf3';
  lineCtx.lineWidth = 2.5;
  lineCtx.shadowColor = '#58a6ff';
  lineCtx.shadowBlur = 4;
  lineCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const x01 = (i / pW) * LINE_LEN;
    const v = totalWave(x01, time, N, alpha, disp, vp0, gamma);
    const px = pad.l + i;
    const py = midY - v * yScale;
    i === 0 ? lineCtx.moveTo(px, py) : lineCtx.lineTo(px, py);
  }
  lineCtx.stroke();
  lineCtx.shadowBlur = 0;

  // Pulse front indicator — leading edge of the fastest harmonic (n=1)
  const frontX = time * vp0;
  if (frontX >= 0 && frontX <= LINE_LEN) {
    const fx = pad.l + (frontX / LINE_LEN) * pW;
    lineCtx.strokeStyle = '#ffffff25';
    lineCtx.lineWidth = 1;
    lineCtx.beginPath(); lineCtx.moveTo(fx, pad.t); lineCtx.lineTo(fx, H - pad.b); lineCtx.stroke();
    lineCtx.fillStyle = '#ffffff40';
    lineCtx.font = '8px sans-serif';
    lineCtx.textAlign = 'center';
    lineCtx.fillText('▼ front', fx, pad.t + 2);
  }

  // Labels
  lineCtx.fillStyle = '#555';
  lineCtx.font = '10px sans-serif';
  lineCtx.textAlign = 'center';
  lineCtx.fillText('Position x along line (0 → L) →', (pad.l + W - pad.r) / 2, H - 3);
  lineCtx.textAlign = 'right';
  lineCtx.fillText('V(x,t)', pad.l - 4, pad.t + 10);

  // Gamma badge
  lineCtx.fillStyle = Math.abs(gamma) < 0.01 ? '#3fb950' : '#f0883e';
  lineCtx.font = 'bold 10px sans-serif';
  lineCtx.textAlign = 'right';
  lineCtx.fillText('Γ=' + gamma.toFixed(2), W - pad.r - 4, pad.t + 12);
}

// ── Draw received waveform (v vs t at x=L, accumulated history) ──
function drawReceived() {
  const W = rcvCvs.width, H = rcvCvs.height;
  const N = +slN.value, Z0 = +slZ0.value, ZL = +slZL.value;
  const alpha = +slAlpha.value, disp = +slDisp.value;
  const vp0 = +slVp.value;
  const gamma = ZL >= 500 ? 1 : ZL === 0 ? -1 : (ZL - Z0) / (ZL + Z0);
  const pad = {l: 30, r: 10, t: 10, b: 16};
  rcvCtx.clearRect(0, 0, W, H);
  drawGrid(rcvCtx, W, H, pad);
  drawAxis(rcvCtx, W, H, pad, 'Time →', 'V');

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 5;

  // Time window: show from 0 to reasonable max (enough to see forward + reflected)
  const tMax = (LINE_LEN / vp0 + T) * 3;

  // Sample current received value into history
  const vNow = totalWave(LINE_LEN, time, N, alpha, disp, vp0, gamma);
  const sampleInterval = tMax / RCV_HIST_LEN;
  if (time - lastRcvSampleTime >= sampleInterval * 0.5 || lastRcvSampleTime < 0) {
    if (rcvHistCount < RCV_HIST_LEN) {
      rcvHistory[rcvHistCount] = vNow;
      rcvHistTime[rcvHistCount] = time;
      rcvHistCount++;
    }
    lastRcvSampleTime = time;
  }

  // Draw received trace from history
  rcvCtx.strokeStyle = '#3fb950';
  rcvCtx.lineWidth = 2.5;
  rcvCtx.shadowColor = '#3fb950';
  rcvCtx.shadowBlur = 6;
  if (rcvHistCount > 1) {
    rcvCtx.beginPath();
    for (let i = 0; i < rcvHistCount; i++) {
      const px = pad.l + (rcvHistTime[i] / tMax) * pW;
      const py = midY - rcvHistory[i] * yScale;
      i === 0 ? rcvCtx.moveTo(px, py) : rcvCtx.lineTo(px, py);
    }
    rcvCtx.stroke();
  }
  rcvCtx.shadowBlur = 0;

  // Current time marker
  const tFrac = time / tMax;
  if (tFrac >= 0 && tFrac <= 1) {
    const mx = pad.l + tFrac * pW;
    rcvCtx.strokeStyle = '#ffffff40';
    rcvCtx.lineWidth = 1;
    rcvCtx.setLineDash([3, 3]);
    rcvCtx.beginPath(); rcvCtx.moveTo(mx, pad.t); rcvCtx.lineTo(mx, H - pad.b); rcvCtx.stroke();
    rcvCtx.setLineDash([]);
    // Dot
    rcvCtx.beginPath();
    rcvCtx.arc(mx, midY - vNow * yScale, 4, 0, Math.PI * 2);
    rcvCtx.fillStyle = '#3fb950';
    rcvCtx.fill();
  }

  // Expected arrival time marker
  const tArrival = LINE_LEN / vp0;
  const arrX = pad.l + (tArrival / tMax) * pW;
  if (arrX > pad.l && arrX < W - pad.r) {
    rcvCtx.strokeStyle = '#ffffff20';
    rcvCtx.lineWidth = 1;
    rcvCtx.setLineDash([2, 2]);
    rcvCtx.beginPath(); rcvCtx.moveTo(arrX, pad.t); rcvCtx.lineTo(arrX, H - pad.b); rcvCtx.stroke();
    rcvCtx.setLineDash([]);
    rcvCtx.fillStyle = '#888';
    rcvCtx.font = '8px sans-serif';
    rcvCtx.textAlign = 'center';
    rcvCtx.fillText('arrives', arrX, pad.t + 8);
  }

  // Label
  rcvCtx.fillStyle = '#3fb950';
  rcvCtx.font = 'bold 10px sans-serif';
  rcvCtx.textAlign = 'left';
  rcvCtx.fillText('At Load (x=L)', pad.l + 4, pad.t + 12);
}

// ── Draw spectrum ──
function drawSpectrum() {
  const W = specCvs.width, H = specCvs.height;
  const N = +slN.value, alpha = +slAlpha.value;
  const pad = {l: 40, r: 20, t: 14, b: 20};
  specCtx.clearRect(0, 0, W, H);

  const pW = W - pad.l - pad.r;
  const pH = H - pad.t - pad.b;

  // Axes
  specCtx.strokeStyle = '#ffffff20';
  specCtx.lineWidth = 1;
  specCtx.beginPath(); specCtx.moveTo(pad.l, H - pad.b); specCtx.lineTo(W - pad.r, H - pad.b); specCtx.stroke();
  specCtx.beginPath(); specCtx.moveTo(pad.l, pad.t); specCtx.lineTo(pad.l, H - pad.b); specCtx.stroke();

  specCtx.fillStyle = '#555';
  specCtx.font = '10px sans-serif';
  specCtx.textAlign = 'center';
  specCtx.fillText('Harmonic number n →', (pad.l + W - pad.r) / 2, H - 2);
  specCtx.textAlign = 'right';
  specCtx.fillText('|aₙ|', pad.l - 4, pad.t + 6);

  const maxN = Math.max(N, 10);
  const barW = Math.max(2, Math.min(20, pW / maxN - 2));

  for (let n = 1; n <= maxN; n++) {
    const an = Math.abs(harmonicCoeff(n));
    const atten = attenFactor(n, alpha, LINE_LEN);
    const barH_src = an * pH / (2 / Math.PI) * 0.9;
    const barH_rcv = an * atten * pH / (2 / Math.PI) * 0.9;
    const cx = pad.l + (n - 0.5) / maxN * pW;

    // Source bar
    specCtx.fillStyle = n <= N ? '#bc8cff80' : '#ffffff10';
    specCtx.fillRect(cx - barW / 2, H - pad.b - barH_src, barW / 2 - 1, barH_src);

    // Received bar (with attenuation)
    if (n <= N) {
      specCtx.fillStyle = '#3fb95080';
      specCtx.fillRect(cx + 1, H - pad.b - barH_rcv, barW / 2 - 1, barH_rcv);
    }

    if (n <= 10 || n % 5 === 0) {
      specCtx.fillStyle = '#555';
      specCtx.font = '8px sans-serif';
      specCtx.textAlign = 'center';
      specCtx.fillText(n, cx, H - pad.b + 10);
    }
  }

  // Legend
  specCtx.fillStyle = '#bc8cff';
  specCtx.fillRect(W - pad.r - 120, pad.t, 8, 8);
  specCtx.fillStyle = '#8b949e';
  specCtx.font = '9px sans-serif';
  specCtx.textAlign = 'left';
  specCtx.fillText('Source', W - pad.r - 108, pad.t + 8);
  specCtx.fillStyle = '#3fb950';
  specCtx.fillRect(W - pad.r - 60, pad.t, 8, 8);
  specCtx.fillStyle = '#8b949e';
  specCtx.fillText('At Load', W - pad.r - 48, pad.t + 8);
}

// ── Draw harmonic decomposition (individual harmonics of the source pulse) ──
function drawHarmonics() {
  const W = harmCvs.width, H = harmCvs.height;
  const N = +slN.value;
  const showN = Math.min(N, 8);
  const pad = {l: 30, r: 10, t: 8, b: 14};
  harmCtx.clearRect(0, 0, W, H);

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 4;
  const tWindow = T * 1.5;

  // Center axis
  harmCtx.strokeStyle = '#ffffff15';
  harmCtx.lineWidth = 1;
  harmCtx.beginPath(); harmCtx.moveTo(pad.l, midY); harmCtx.lineTo(W - pad.r, midY); harmCtx.stroke();

  // T boundary
  const tEndX = pad.l + (T / tWindow) * pW;
  harmCtx.strokeStyle = '#ffffff15';
  harmCtx.lineWidth = 1;
  harmCtx.setLineDash([2, 2]);
  harmCtx.beginPath(); harmCtx.moveTo(tEndX, pad.t); harmCtx.lineTo(tEndX, H - pad.b); harmCtx.stroke();
  harmCtx.setLineDash([]);

  // Individual harmonics (windowed to 0..T)
  for (let n = 1; n <= showN; n++) {
    const an = harmonicCoeff(n);
    const col = HARM_COLORS[(n - 1) % HARM_COLORS.length];
    harmCtx.strokeStyle = col;
    harmCtx.lineWidth = 1.2;
    harmCtx.globalAlpha = 0.6;
    harmCtx.beginPath();
    let started = false;
    for (let i = 0; i <= pW; i++) {
      const tPlot = (i / pW) * tWindow;
      const v = (tPlot >= 0 && tPlot <= T) ? an * Math.sin(n * omega * tPlot) : 0;
      const px = pad.l + i;
      const py = midY - v * yScale;
      if (!started) { harmCtx.moveTo(px, py); started = true; }
      else harmCtx.lineTo(px, py);
    }
    harmCtx.stroke();
    harmCtx.globalAlpha = 1;

    harmCtx.fillStyle = col;
    harmCtx.font = '8px sans-serif';
    harmCtx.textAlign = 'left';
    harmCtx.fillText('n=' + n, W - pad.r - 30, pad.t + 10 + (n - 1) * 10);
  }

  // Sum (the full pulse)
  harmCtx.strokeStyle = '#e6edf3';
  harmCtx.lineWidth = 2;
  harmCtx.beginPath();
  let started = false;
  for (let i = 0; i <= pW; i++) {
    const tPlot = (i / pW) * tWindow;
    const v = sourcePulse(tPlot, N);
    const px = pad.l + i;
    const py = midY - v * yScale;
    if (!started) { harmCtx.moveTo(px, py); started = true; }
    else harmCtx.lineTo(px, py);
  }
  harmCtx.stroke();

  harmCtx.fillStyle = '#555';
  harmCtx.font = '9px sans-serif';
  harmCtx.textAlign = 'center';
  harmCtx.fillText('Time (0 to 1.5T) →', (pad.l + W - pad.r) / 2, H - 2);
}

// ── Main animation loop ──
function animate(ts) {
  if (!lastTS) lastTS = ts;
  const dt = (ts - lastTS) / 1000;
  lastTS = ts;

  if (!paused) {
    time += dt * parseFloat(slSpeed.value);
  }

  updMeters();
  drawSource();
  drawLine();
  drawReceived();
  drawSpectrum();
  drawHarmonics();

  requestAnimationFrame(animate);
}

updLabels();
requestAnimationFrame(animate);
</script>
</body>
</html>
