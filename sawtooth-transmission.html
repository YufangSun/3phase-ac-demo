<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sawtooth Wave on a Transmission Line</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{font-size:1.5em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.92em;text-align:center;max-width:820px}
  canvas{display:block;border-radius:10px}
  .row{display:flex;flex-wrap:wrap;gap:12px;justify-content:center;margin-top:10px;max-width:1160px;width:100%}
  .panel{background:#161b22;border-radius:12px;padding:12px;border:1px solid #30363d;flex:1;min-width:260px}
  .panel h2{font-size:.88em;color:#8b949e;margin-bottom:4px;text-align:center}
  .wide{flex:2;min-width:540px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;justify-content:center;align-items:center}
  .cg{display:flex;align-items:center;gap:4px}
  .cg label{font-size:.78em;color:#8b949e;white-space:nowrap}
  input[type="range"]{width:90px;accent-color:#f78166}
  .val{font-size:.78em;color:#f78166;min-width:30px}
  button{background:#238636;color:white;border:none;padding:6px 14px;border-radius:6px;
    cursor:pointer;font-size:.82em;transition:.2s}
  button:hover{background:#2ea043}
  button.sec{background:#30363d}
  button.sec:hover{background:#484f58}
  .presets{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:8px}
  .preset{padding:4px 12px;border-radius:6px;cursor:pointer;font-size:.76em;
    background:#21262d;border:1px solid #30363d;color:#8b949e;transition:.2s}
  .preset:hover{border-color:#58a6ff;color:#e6edf3}
  .preset.active{background:#1f6feb;border-color:#1f6feb;color:white}
  .meters{display:flex;gap:8px;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .meter{background:#161b22;border:1px solid #30363d;border-radius:8px;padding:4px 10px;text-align:center;min-width:90px}
  .meter .ml{font-size:.68em;color:#8b949e}
  .meter .mv{font-size:.88em;font-weight:bold;font-family:'Courier New',monospace}
  .legend{display:flex;gap:12px;justify-content:center;margin:6px 0;flex-wrap:wrap}
  .legend-item{display:flex;align-items:center;gap:4px;font-size:.76em}
  .legend-dot{width:9px;height:9px;border-radius:50%}
  .info{max-width:1160px;width:100%;background:#161b22;border-radius:12px;
    padding:14px 18px;border:1px solid #30363d;margin-top:14px;font-size:.84em;line-height:1.6;color:#8b949e}
  .info strong{color:#e0e0ff}
  .info code{color:#f78166;background:#21262d;padding:1px 4px;border-radius:3px}
  a{color:#58a6ff}
  .eq-box{background:#161b22;border:1px solid #30363d;border-radius:10px;
    padding:8px 14px;margin:6px 0;max-width:1160px;width:100%;text-align:center}
  .eq{font-size:1.05em;font-family:'Times New Roman',serif;color:#e0e0ff}
  .eq-desc{font-size:.78em;color:#7d8590;margin-top:2px}
</style>
</head>
<body>

<h1>Sawtooth Wave on a Transmission Line</h1>
<p class="subtitle">Watch how a sawtooth wave — built from Fourier harmonics — propagates, reflects, disperses, and attenuates along a transmission line</p>

<div class="eq-box">
  <div class="eq">v(t) = Σ<sub>n=1</sub><sup>N</sup> (2V<sub>p</sub> / nπ) · (−1)<sup>n+1</sup> sin(nωt) &nbsp;→&nbsp; propagate along Z₀ &nbsp;→&nbsp; reflect at Γ<sub>L</sub> = (Z<sub>L</sub>−Z₀)/(Z<sub>L</sub>+Z₀)</div>
  <div class="eq-desc">Each harmonic travels independently — higher harmonics suffer more attenuation and dispersion, distorting the sharp edges</div>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#f78166"></div> Source (sawtooth)</div>
  <div class="legend-item"><div class="legend-dot" style="background:#58a6ff"></div> Forward wave</div>
  <div class="legend-item"><div class="legend-dot" style="background:#f0883e"></div> Reflected wave</div>
  <div class="legend-item"><div class="legend-dot" style="background:#3fb950"></div> Received at load</div>
  <div class="legend-item"><div class="legend-dot" style="background:#bc8cff"></div> Individual harmonics</div>
</div>

<div class="row">
  <div class="panel">
    <h2>Source Waveform</h2>
    <canvas id="srcCanvas" width="360" height="200"></canvas>
  </div>
  <div class="panel wide">
    <h2>Transmission Line — Spatial View</h2>
    <canvas id="lineCanvas" width="720" height="200"></canvas>
  </div>
  <div class="panel">
    <h2>Received at Load</h2>
    <canvas id="rcvCanvas" width="360" height="200"></canvas>
  </div>
</div>

<div class="row">
  <div class="panel wide">
    <h2>Fourier Harmonics Spectrum</h2>
    <canvas id="specCanvas" width="720" height="180"></canvas>
  </div>
  <div class="panel">
    <h2>Harmonic Decomposition</h2>
    <canvas id="harmCanvas" width="360" height="180"></canvas>
  </div>
</div>

<div class="meters" id="meterBox">
  <div class="meter"><div class="ml">Harmonics N</div><div class="mv" id="mN">15</div></div>
  <div class="meter"><div class="ml">Γ<sub>L</sub> (load)</div><div class="mv" id="mGamma">0.00</div></div>
  <div class="meter"><div class="ml">Z₀</div><div class="mv" id="mZ0">50 Ω</div></div>
  <div class="meter"><div class="ml">Z<sub>L</sub></div><div class="mv" id="mZL">50 Ω</div></div>
  <div class="meter"><div class="ml">v<sub>p</sub></div><div class="mv" id="mVp">0.67c</div></div>
  <div class="meter"><div class="ml">α (atten)</div><div class="mv" id="mAlpha">0.0 dB/m</div></div>
  <div class="meter"><div class="ml">Dispersion</div><div class="mv" id="mDisp">Off</div></div>
  <div class="meter"><div class="ml">Rise time (load)</div><div class="mv" id="mRise">—</div></div>
</div>

<div class="controls">
  <div class="cg">
    <label>Harmonics N:</label>
    <input type="range" id="slN" min="1" max="50" step="1" value="15">
    <span class="val" id="vN">15</span>
  </div>
  <div class="cg">
    <label>Z₀ (Ω):</label>
    <input type="range" id="slZ0" min="10" max="200" step="5" value="50">
    <span class="val" id="vZ0">50</span>
  </div>
  <div class="cg">
    <label>Z<sub>L</sub> (Ω):</label>
    <input type="range" id="slZL" min="0" max="500" step="5" value="50">
    <span class="val" id="vZL">50</span>
  </div>
  <div class="cg">
    <label>Attenuation:</label>
    <input type="range" id="slAlpha" min="0" max="3" step="0.1" value="0">
    <span class="val" id="vAlpha">0</span>
  </div>
  <div class="cg">
    <label>Dispersion:</label>
    <input type="range" id="slDisp" min="0" max="1" step="0.05" value="0">
    <span class="val" id="vDisp">0</span>
  </div>
  <div class="cg">
    <label>Frequency:</label>
    <input type="range" id="slFreq" min="0.3" max="3" step="0.1" value="1">
    <span class="val" id="vFreq">1.0</span>
  </div>
  <div class="cg">
    <label>Speed:</label>
    <input type="range" id="slSpeed" min="0.1" max="3" step="0.1" value="1">
    <span class="val" id="vSpeed">1.0</span>
  </div>
  <button id="btnPause">Pause</button>
  <button id="btnReset" class="sec">Reset</button>
</div>

<div class="presets">
  <div class="preset active" data-p="matched">Matched Load</div>
  <div class="preset" data-p="open">Open End</div>
  <div class="preset" data-p="short">Short Circuit</div>
  <div class="preset" data-p="lossy">Lossy Line</div>
  <div class="preset" data-p="dispersive">Dispersive</div>
  <div class="preset" data-p="lossy-dispersive">Lossy + Dispersive</div>
  <div class="preset" data-p="single">Single Harmonic</div>
  <div class="preset" data-p="square">→ Square Wave</div>
</div>

<div class="info">
  <strong>How It Works:</strong>
  A sawtooth wave is decomposed into Fourier harmonics: <code>v(t) = Σ (2Vp/nπ)(−1)^(n+1) sin(nωt)</code>.
  Each harmonic propagates independently along the transmission line with characteristic impedance <strong>Z₀</strong>.
  <br><br>
  <strong>Attenuation</strong> causes higher-frequency harmonics to decay faster (α ∝ √f for skin effect), rounding sharp edges.
  <strong>Dispersion</strong> makes each harmonic travel at a slightly different phase velocity (v<sub>p</sub> ∝ 1/√n), spreading the waveform in time.
  At the <strong>load</strong>, each harmonic partially reflects with Γ<sub>L</sub> = (Z<sub>L</sub>−Z₀)/(Z<sub>L</sub>+Z₀).
  An open end (Γ=+1) reflects in-phase, a short (Γ=−1) inverts. A matched load (Z<sub>L</sub>=Z₀) has zero reflection.
  <br><br>
  Watch the "Square Wave" preset to compare: a square wave uses only odd harmonics <code>(2Vp/nπ) sin(nωt)</code> for odd n.
  <br><br>
  <a href="index.html">← 3-Phase AC</a> ·
  <a href="mutual-inductance.html">Mutual Inductance</a> ·
  <a href="bounce-diagram.html">Bounce Diagram</a> ·
  <a href="transformer.html">Transformer</a> ·
  <a href="maxwell.html">Maxwell's Equations</a> ·
  <a href="poynting.html">Poynting Theorem</a> ·
  <a href="vectors.html">Dot &amp; Cross Product</a> ·
  <a href="phasor-transform.html">Phasor Transform</a>
</div>

<script>
// ── Canvases ──
const srcCvs = document.getElementById('srcCanvas');
const lineCvs = document.getElementById('lineCanvas');
const rcvCvs = document.getElementById('rcvCanvas');
const specCvs = document.getElementById('specCanvas');
const harmCvs = document.getElementById('harmCanvas');
const srcCtx = srcCvs.getContext('2d');
const lineCtx = lineCvs.getContext('2d');
const rcvCtx = rcvCvs.getContext('2d');
const specCtx = specCvs.getContext('2d');
const harmCtx = harmCvs.getContext('2d');

// ── Controls ──
const slN = document.getElementById('slN');
const slZ0 = document.getElementById('slZ0');
const slZL = document.getElementById('slZL');
const slAlpha = document.getElementById('slAlpha');
const slDisp = document.getElementById('slDisp');
const slFreq = document.getElementById('slFreq');
const slSpeed = document.getElementById('slSpeed');

let paused = false;
let time = 0;
let lastTS = 0;
let waveType = 'sawtooth'; // 'sawtooth' or 'square'

// ── Slider labels ──
function updLabels() {
  document.getElementById('vN').textContent = slN.value;
  document.getElementById('vZ0').textContent = slZ0.value;
  document.getElementById('vZL').textContent = slZL.value;
  document.getElementById('vAlpha').textContent = parseFloat(slAlpha.value).toFixed(1);
  document.getElementById('vDisp').textContent = parseFloat(slDisp.value).toFixed(2);
  document.getElementById('vFreq').textContent = parseFloat(slFreq.value).toFixed(1);
  document.getElementById('vSpeed').textContent = parseFloat(slSpeed.value).toFixed(1);
}
[slN, slZ0, slZL, slAlpha, slDisp, slFreq, slSpeed].forEach(s => s.oninput = updLabels);

// ── Meters ──
function updMeters() {
  const N = +slN.value, Z0 = +slZ0.value, ZL = +slZL.value;
  const alpha = +slAlpha.value, disp = +slDisp.value;
  const gamma = ZL >= 1e6 ? 1 : (ZL - Z0) / (ZL + Z0);
  document.getElementById('mN').textContent = N;
  document.getElementById('mGamma').textContent = gamma.toFixed(3);
  document.getElementById('mZ0').textContent = Z0 + ' Ω';
  document.getElementById('mZL').textContent = ZL >= 1e6 ? '∞ (open)' : ZL === 0 ? '0 (short)' : ZL + ' Ω';
  document.getElementById('mVp').textContent = '0.67c';
  document.getElementById('mAlpha').textContent = alpha.toFixed(1) + ' dB/m';
  document.getElementById('mDisp').textContent = disp > 0 ? 'On (' + (disp * 100).toFixed(0) + '%)' : 'Off';
}

// ── Presets ──
document.querySelectorAll('.preset').forEach(el => {
  el.addEventListener('click', () => {
    document.querySelectorAll('.preset').forEach(e => e.classList.remove('active'));
    el.classList.add('active');
    const p = el.dataset.p;
    waveType = 'sawtooth';
    switch(p) {
      case 'matched':
        slN.value=15; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slFreq.value=1;
        break;
      case 'open':
        slN.value=15; slZ0.value=50; slZL.value=500; slAlpha.value=0; slDisp.value=0; slFreq.value=1;
        break;
      case 'short':
        slN.value=15; slZ0.value=50; slZL.value=0; slAlpha.value=0; slDisp.value=0; slFreq.value=1;
        break;
      case 'lossy':
        slN.value=25; slZ0.value=50; slZL.value=50; slAlpha.value=1.5; slDisp.value=0; slFreq.value=1;
        break;
      case 'dispersive':
        slN.value=25; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0.6; slFreq.value=1;
        break;
      case 'lossy-dispersive':
        slN.value=30; slZ0.value=50; slZL.value=75; slAlpha.value=1.0; slDisp.value=0.4; slFreq.value=1;
        break;
      case 'single':
        slN.value=1; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slFreq.value=1;
        break;
      case 'square':
        slN.value=20; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slFreq.value=1;
        waveType = 'square';
        break;
    }
    updLabels();
    time = 0;
  });
});

// ── Pause / Reset ──
document.getElementById('btnPause').onclick = () => {
  paused = !paused;
  document.getElementById('btnPause').textContent = paused ? 'Play' : 'Pause';
};
document.getElementById('btnReset').onclick = () => {
  time = 0; paused = false;
  document.getElementById('btnPause').textContent = 'Pause';
  slN.value=15; slZ0.value=50; slZL.value=50; slAlpha.value=0; slDisp.value=0; slFreq.value=1; slSpeed.value=1;
  waveType = 'sawtooth';
  document.querySelectorAll('.preset').forEach(e => e.classList.remove('active'));
  document.querySelector('[data-p="matched"]').classList.add('active');
  updLabels();
};

// ── Physics helpers ──
function harmonicCoeff(n) {
  // Sawtooth: (2/(nπ))(-1)^(n+1) = alternating sign
  // Square: (2/(nπ)) for odd n only, 0 for even
  if (waveType === 'square') {
    if (n % 2 === 0) return 0;
    return 2 / (n * Math.PI);
  }
  return 2 / (n * Math.PI) * Math.pow(-1, n + 1);
}

function attenFactor(n, alpha, lineLen) {
  // Higher harmonics attenuated more: α_n = α * sqrt(n)  (skin effect model)
  if (alpha === 0) return 1;
  const alpha_n = alpha * Math.sqrt(n);
  return Math.exp(-alpha_n * lineLen * 0.3); // scale for visual
}

function dispPhase(n, disp) {
  // Phase velocity depends on harmonic: v_n = v0 / (1 + disp*(n-1)/N)
  // This gives a phase shift accumulation
  if (disp === 0) return 0;
  return disp * (n - 1) * 0.15; // radians of extra phase shift per harmonic
}

function computeWave(tVal, N, alpha, disp, lineLen, atLine) {
  // atLine: 0 = source, 1 = end of line (received)
  let v = 0;
  for (let n = 1; n <= N; n++) {
    const an = harmonicCoeff(n);
    if (an === 0) continue;
    const atten = atLine > 0 ? attenFactor(n, alpha, lineLen) : 1;
    const extraPhase = atLine > 0 ? dispPhase(n, disp) * lineLen : 0;
    v += an * atten * Math.sin(n * tVal - extraPhase);
  }
  return v;
}

// Compute wave at a position x along the line (0 to 1) at time t
function computeLineWave(tVal, x, N, alpha, disp, gamma) {
  let v = 0;
  const lineLen = 1;
  for (let n = 1; n <= N; n++) {
    const an = harmonicCoeff(n);
    if (an === 0) continue;
    const atten_fwd = attenFactor(n, alpha, x);
    const extraPhase_fwd = dispPhase(n, disp) * x;
    // Forward wave
    const fwd = an * atten_fwd * Math.sin(n * tVal - n * x * 2 * Math.PI - extraPhase_fwd);
    // Reflected wave (from load at x=1, traveling backward)
    const atten_ref = attenFactor(n, alpha, 2 - x); // traveled to end and back
    const extraPhase_ref = dispPhase(n, disp) * (2 - x);
    const ref = an * gamma * atten_ref * Math.sin(n * tVal - n * (2 - x) * 2 * Math.PI - extraPhase_ref);
    v += fwd + ref;
  }
  return v;
}

// ── Drawing helpers ──
function drawGrid(ctx, W, H, pad) {
  ctx.strokeStyle = '#ffffff08';
  ctx.lineWidth = 1;
  const l = pad.l || 0, r = pad.r || 0, t = pad.t || 0, b = pad.b || 0;
  for (let i = 0; i <= 4; i++) {
    const y = t + (H - t - b) * i / 4;
    ctx.beginPath(); ctx.moveTo(l, y); ctx.lineTo(W - r, y); ctx.stroke();
  }
  for (let i = 0; i <= 8; i++) {
    const x = l + (W - l - r) * i / 8;
    ctx.beginPath(); ctx.moveTo(x, t); ctx.lineTo(x, H - b); ctx.stroke();
  }
}

function drawAxis(ctx, W, H, pad, xLabel, yLabel) {
  const l = pad.l || 0, r = pad.r || 0, t = pad.t || 0, b = pad.b || 0;
  const midY = (t + H - b) / 2;
  ctx.strokeStyle = '#ffffff20';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(l, midY); ctx.lineTo(W - r, midY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(l, t); ctx.lineTo(l, H - b); ctx.stroke();
  ctx.fillStyle = '#555';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  if (xLabel) ctx.fillText(xLabel, (l + W - r) / 2, H - 2);
  ctx.textAlign = 'right';
  if (yLabel) ctx.fillText(yLabel, l - 3, t + 8);
}

const HARM_COLORS = [
  '#ff6b6b','#ffa94d','#ffd43b','#69db7c','#38d9a9',
  '#4dabf7','#748ffc','#9775fa','#da77f2','#f783ac',
  '#ff8787','#ffb366','#ffe066','#8ce99a','#63e6be',
  '#74c0fc','#91a7ff','#b197fc','#e599f7','#faa2c1'
];

// ── Draw source waveform ──
function drawSource() {
  const W = srcCvs.width, H = srcCvs.height;
  const N = +slN.value, freq = +slFreq.value;
  const pad = {l: 30, r: 10, t: 10, b: 16};
  srcCtx.clearRect(0, 0, W, H);
  drawGrid(srcCtx, W, H, pad);
  drawAxis(srcCtx, W, H, pad, 'Time →', 'V');

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 5;

  // Ideal sawtooth (thin gray)
  srcCtx.strokeStyle = '#ffffff15';
  srcCtx.lineWidth = 1;
  srcCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const tNorm = (i / pW) * 2; // 2 cycles
    const phase = (tNorm * freq + time * freq) % 1;
    const ideal = waveType === 'square'
      ? (phase < 0.5 ? 1 : -1)
      : 2 * phase - 1; // sawtooth -1 to +1
    const x = pad.l + i;
    const y = midY - ideal * yScale;
    i === 0 ? srcCtx.moveTo(x, y) : srcCtx.lineTo(x, y);
  }
  srcCtx.stroke();

  // Fourier-synthesized source
  srcCtx.strokeStyle = '#f78166';
  srcCtx.lineWidth = 2.5;
  srcCtx.shadowColor = '#f78166';
  srcCtx.shadowBlur = 6;
  srcCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const tNorm = (i / pW) * 2 * 2 * Math.PI; // 2 cycles in radians
    const tVal = tNorm * freq + time * freq * 2 * Math.PI;
    const v = computeWave(tVal, N, 0, 0, 0, 0);
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? srcCtx.moveTo(x, y) : srcCtx.lineTo(x, y);
  }
  srcCtx.stroke();
  srcCtx.shadowBlur = 0;

  // Label
  srcCtx.fillStyle = '#f78166';
  srcCtx.font = 'bold 10px sans-serif';
  srcCtx.textAlign = 'left';
  srcCtx.fillText(waveType === 'square' ? 'Square' : 'Sawtooth', pad.l + 4, pad.t + 12);
  srcCtx.fillStyle = '#555';
  srcCtx.fillText('N=' + N, pad.l + 4 + (waveType === 'square' ? 50 : 65), pad.t + 12);
}

// ── Draw transmission line spatial view ──
function drawLine() {
  const W = lineCvs.width, H = lineCvs.height;
  const N = +slN.value, Z0 = +slZ0.value, ZL = +slZL.value;
  const alpha = +slAlpha.value, disp = +slDisp.value, freq = +slFreq.value;
  const gamma = ZL >= 500 ? 1 : ZL === 0 ? -1 : (ZL - Z0) / (ZL + Z0);
  const pad = {l: 40, r: 30, t: 12, b: 20};
  lineCtx.clearRect(0, 0, W, H);
  drawGrid(lineCtx, W, H, pad);

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 8;

  // Axis
  lineCtx.strokeStyle = '#ffffff20';
  lineCtx.lineWidth = 1;
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, midY); lineCtx.lineTo(W - pad.r, midY); lineCtx.stroke();

  // Source and load markers
  lineCtx.strokeStyle = '#f78166';
  lineCtx.lineWidth = 2;
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, pad.t + 8); lineCtx.lineTo(pad.l, H - pad.b - 8); lineCtx.stroke();
  lineCtx.fillStyle = '#f78166';
  lineCtx.font = '9px sans-serif';
  lineCtx.textAlign = 'center';
  lineCtx.fillText('SRC', pad.l, H - pad.b + 10);

  lineCtx.strokeStyle = '#3fb950';
  lineCtx.lineWidth = 2;
  lineCtx.beginPath(); lineCtx.moveTo(W - pad.r, pad.t + 8); lineCtx.lineTo(W - pad.r, H - pad.b - 8); lineCtx.stroke();
  lineCtx.fillStyle = '#3fb950';
  lineCtx.fillText('LOAD', W - pad.r, H - pad.b + 10);

  // Transmission line traces (thin parallel lines)
  lineCtx.strokeStyle = '#ffffff08';
  lineCtx.lineWidth = 1;
  const lY1 = pad.t + 4, lY2 = H - pad.b - 4;
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, lY1); lineCtx.lineTo(W - pad.r, lY1); lineCtx.stroke();
  lineCtx.beginPath(); lineCtx.moveTo(pad.l, lY2); lineCtx.lineTo(W - pad.r, lY2); lineCtx.stroke();

  const tVal = time * freq * 2 * Math.PI;

  // Forward wave (blue)
  lineCtx.strokeStyle = '#58a6ff';
  lineCtx.lineWidth = 1.5;
  lineCtx.globalAlpha = 0.5;
  lineCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const x01 = i / pW; // 0 to 1 along line
    let v = 0;
    for (let n = 1; n <= N; n++) {
      const an = harmonicCoeff(n);
      if (an === 0) continue;
      const atten_fwd = attenFactor(n, alpha, x01);
      const extraPhase_fwd = dispPhase(n, disp) * x01;
      v += an * atten_fwd * Math.sin(n * tVal - n * x01 * 2 * Math.PI - extraPhase_fwd);
    }
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? lineCtx.moveTo(x, y) : lineCtx.lineTo(x, y);
  }
  lineCtx.stroke();
  lineCtx.globalAlpha = 1;

  // Reflected wave (orange) — only if gamma != 0
  if (Math.abs(gamma) > 0.01) {
    lineCtx.strokeStyle = '#f0883e';
    lineCtx.lineWidth = 1.5;
    lineCtx.globalAlpha = 0.5;
    lineCtx.setLineDash([4, 3]);
    lineCtx.beginPath();
    for (let i = 0; i <= pW; i++) {
      const x01 = i / pW;
      let v = 0;
      for (let n = 1; n <= N; n++) {
        const an = harmonicCoeff(n);
        if (an === 0) continue;
        const atten_ref = attenFactor(n, alpha, 2 - x01);
        const extraPhase_ref = dispPhase(n, disp) * (2 - x01);
        v += an * gamma * atten_ref * Math.sin(n * tVal - n * (2 - x01) * 2 * Math.PI - extraPhase_ref);
      }
      const x = pad.l + i;
      const y = midY - v * yScale;
      i === 0 ? lineCtx.moveTo(x, y) : lineCtx.lineTo(x, y);
    }
    lineCtx.stroke();
    lineCtx.setLineDash([]);
    lineCtx.globalAlpha = 1;
  }

  // Total wave (bright white)
  lineCtx.strokeStyle = '#e6edf3';
  lineCtx.lineWidth = 2.5;
  lineCtx.shadowColor = '#58a6ff';
  lineCtx.shadowBlur = 4;
  lineCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const x01 = i / pW;
    const v = computeLineWave(tVal, x01, N, alpha, disp, gamma);
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? lineCtx.moveTo(x, y) : lineCtx.lineTo(x, y);
  }
  lineCtx.stroke();
  lineCtx.shadowBlur = 0;

  // Moving position indicator (pulse front)
  const frontPos = (time * freq * 0.5) % 1.4; // wraps
  if (frontPos <= 1) {
    const fx = pad.l + frontPos * pW;
    lineCtx.strokeStyle = '#ffffff30';
    lineCtx.lineWidth = 1;
    lineCtx.beginPath(); lineCtx.moveTo(fx, pad.t); lineCtx.lineTo(fx, H - pad.b); lineCtx.stroke();
    lineCtx.fillStyle = '#ffffff40';
    lineCtx.font = '8px sans-serif';
    lineCtx.textAlign = 'center';
    lineCtx.fillText('▼', fx, pad.t + 2);
  }

  // Position label
  lineCtx.fillStyle = '#555';
  lineCtx.font = '10px sans-serif';
  lineCtx.textAlign = 'center';
  lineCtx.fillText('Position along line →', (pad.l + W - pad.r) / 2, H - 3);
  lineCtx.textAlign = 'right';
  lineCtx.fillText('V(x)', pad.l - 4, pad.t + 10);

  // Gamma badge
  const gammaStr = 'Γ=' + gamma.toFixed(2);
  lineCtx.fillStyle = Math.abs(gamma) < 0.01 ? '#3fb950' : '#f0883e';
  lineCtx.font = 'bold 10px sans-serif';
  lineCtx.textAlign = 'right';
  lineCtx.fillText(gammaStr, W - pad.r - 4, pad.t + 12);
}

// ── Draw received waveform ──
function drawReceived() {
  const W = rcvCvs.width, H = rcvCvs.height;
  const N = +slN.value, Z0 = +slZ0.value, ZL = +slZL.value;
  const alpha = +slAlpha.value, disp = +slDisp.value, freq = +slFreq.value;
  const gamma = ZL >= 500 ? 1 : ZL === 0 ? -1 : (ZL - Z0) / (ZL + Z0);
  const pad = {l: 30, r: 10, t: 10, b: 16};
  rcvCtx.clearRect(0, 0, W, H);
  drawGrid(rcvCtx, W, H, pad);
  drawAxis(rcvCtx, W, H, pad, 'Time →', 'V');

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 5;

  // Received = forward + reflected at x=1
  rcvCtx.strokeStyle = '#3fb950';
  rcvCtx.lineWidth = 2.5;
  rcvCtx.shadowColor = '#3fb950';
  rcvCtx.shadowBlur = 6;
  rcvCtx.beginPath();
  let vMax = 0, vMin = 0;
  for (let i = 0; i <= pW; i++) {
    const tNorm = (i / pW) * 2 * 2 * Math.PI;
    const tVal = tNorm * freq + time * freq * 2 * Math.PI;
    const v = computeLineWave(tVal, 1, N, alpha, disp, gamma);
    if (v > vMax) vMax = v;
    if (v < vMin) vMin = v;
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? rcvCtx.moveTo(x, y) : rcvCtx.lineTo(x, y);
  }
  rcvCtx.stroke();
  rcvCtx.shadowBlur = 0;

  // Also overlay the ideal source shape (dimmed)
  rcvCtx.strokeStyle = '#f7816630';
  rcvCtx.lineWidth = 1;
  rcvCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const tNorm = (i / pW) * 2 * 2 * Math.PI;
    const tVal = tNorm * freq + time * freq * 2 * Math.PI;
    const v = computeWave(tVal, N, 0, 0, 0, 0);
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? rcvCtx.moveTo(x, y) : rcvCtx.lineTo(x, y);
  }
  rcvCtx.stroke();

  // Label
  rcvCtx.fillStyle = '#3fb950';
  rcvCtx.font = 'bold 10px sans-serif';
  rcvCtx.textAlign = 'left';
  rcvCtx.fillText('At Load (x=L)', pad.l + 4, pad.t + 12);

  // Rise time estimate
  const peakV = Math.max(Math.abs(vMax), Math.abs(vMin));
  document.getElementById('mRise').textContent = N > 1 ? '~' + (1 / (N * freq)).toFixed(3) + 's' : '—';
}

// ── Draw spectrum ──
function drawSpectrum() {
  const W = specCvs.width, H = specCvs.height;
  const N = +slN.value, alpha = +slAlpha.value;
  const pad = {l: 40, r: 20, t: 14, b: 20};
  specCtx.clearRect(0, 0, W, H);

  const pW = W - pad.l - pad.r;
  const pH = H - pad.t - pad.b;

  // Axes
  specCtx.strokeStyle = '#ffffff20';
  specCtx.lineWidth = 1;
  specCtx.beginPath(); specCtx.moveTo(pad.l, H - pad.b); specCtx.lineTo(W - pad.r, H - pad.b); specCtx.stroke();
  specCtx.beginPath(); specCtx.moveTo(pad.l, pad.t); specCtx.lineTo(pad.l, H - pad.b); specCtx.stroke();

  specCtx.fillStyle = '#555';
  specCtx.font = '10px sans-serif';
  specCtx.textAlign = 'center';
  specCtx.fillText('Harmonic number n →', (pad.l + W - pad.r) / 2, H - 2);
  specCtx.textAlign = 'right';
  specCtx.fillText('|aₙ|', pad.l - 4, pad.t + 6);

  const maxN = Math.max(N, 10);
  const barW = Math.max(2, Math.min(20, pW / maxN - 2));

  for (let n = 1; n <= maxN; n++) {
    const an = Math.abs(harmonicCoeff(n));
    if (an === 0) continue;
    const atten = attenFactor(n, alpha, 1);
    const barH_src = an * pH / (2 / Math.PI) * 0.9;
    const barH_rcv = an * atten * pH / (2 / Math.PI) * 0.9;
    const cx = pad.l + (n - 0.5) / maxN * pW;

    // Source bar
    specCtx.fillStyle = n <= N ? '#bc8cff80' : '#ffffff10';
    specCtx.fillRect(cx - barW / 2, H - pad.b - barH_src, barW / 2 - 1, barH_src);

    // Received bar (with attenuation)
    if (n <= N) {
      specCtx.fillStyle = '#3fb95080';
      specCtx.fillRect(cx + 1, H - pad.b - barH_rcv, barW / 2 - 1, barH_rcv);
    }

    // Label every few bars
    if (n <= 10 || n % 5 === 0) {
      specCtx.fillStyle = '#555';
      specCtx.font = '8px sans-serif';
      specCtx.textAlign = 'center';
      specCtx.fillText(n, cx, H - pad.b + 10);
    }
  }

  // Legend
  specCtx.fillStyle = '#bc8cff';
  specCtx.fillRect(W - pad.r - 120, pad.t, 8, 8);
  specCtx.fillStyle = '#8b949e';
  specCtx.font = '9px sans-serif';
  specCtx.textAlign = 'left';
  specCtx.fillText('Source', W - pad.r - 108, pad.t + 8);
  specCtx.fillStyle = '#3fb950';
  specCtx.fillRect(W - pad.r - 60, pad.t, 8, 8);
  specCtx.fillStyle = '#8b949e';
  specCtx.fillText('At Load', W - pad.r - 48, pad.t + 8);
}

// ── Draw harmonic decomposition ──
function drawHarmonics() {
  const W = harmCvs.width, H = harmCvs.height;
  const N = Math.min(+slN.value, 8); // show up to 8 harmonics
  const freq = +slFreq.value;
  const pad = {l: 30, r: 10, t: 8, b: 14};
  harmCtx.clearRect(0, 0, W, H);

  const pW = W - pad.l - pad.r;
  const midY = (pad.t + H - pad.b) / 2;
  const yScale = (H - pad.t - pad.b) / 2 - 4;

  // Axis
  harmCtx.strokeStyle = '#ffffff15';
  harmCtx.lineWidth = 1;
  harmCtx.beginPath(); harmCtx.moveTo(pad.l, midY); harmCtx.lineTo(W - pad.r, midY); harmCtx.stroke();

  const totalN = +slN.value;

  // Draw individual harmonics
  for (let n = 1; n <= Math.min(totalN, 8); n++) {
    const an = harmonicCoeff(n);
    if (an === 0) continue;
    const col = HARM_COLORS[(n - 1) % HARM_COLORS.length];
    harmCtx.strokeStyle = col;
    harmCtx.lineWidth = 1.2;
    harmCtx.globalAlpha = 0.6;
    harmCtx.beginPath();
    for (let i = 0; i <= pW; i++) {
      const tNorm = (i / pW) * 2 * 2 * Math.PI;
      const tVal = tNorm * freq + time * freq * 2 * Math.PI;
      const v = an * Math.sin(n * tVal);
      const x = pad.l + i;
      const y = midY - v * yScale;
      i === 0 ? harmCtx.moveTo(x, y) : harmCtx.lineTo(x, y);
    }
    harmCtx.stroke();
    harmCtx.globalAlpha = 1;

    // Label
    harmCtx.fillStyle = col;
    harmCtx.font = '8px sans-serif';
    harmCtx.textAlign = 'left';
    harmCtx.fillText('n=' + n, W - pad.r - 30, pad.t + 10 + (n - 1) * 10);
  }

  // Sum on top
  harmCtx.strokeStyle = '#e6edf3';
  harmCtx.lineWidth = 2;
  harmCtx.beginPath();
  for (let i = 0; i <= pW; i++) {
    const tNorm = (i / pW) * 2 * 2 * Math.PI;
    const tVal = tNorm * freq + time * freq * 2 * Math.PI;
    const v = computeWave(tVal, totalN, 0, 0, 0, 0);
    const x = pad.l + i;
    const y = midY - v * yScale;
    i === 0 ? harmCtx.moveTo(x, y) : harmCtx.lineTo(x, y);
  }
  harmCtx.stroke();

  harmCtx.fillStyle = '#555';
  harmCtx.font = '9px sans-serif';
  harmCtx.textAlign = 'center';
  harmCtx.fillText('Time →', (pad.l + W - pad.r) / 2, H - 2);
}

// ── Main animation loop ──
function animate(ts) {
  if (!lastTS) lastTS = ts;
  const dt = (ts - lastTS) / 1000;
  lastTS = ts;

  if (!paused) {
    time += dt * parseFloat(slSpeed.value);
  }

  updMeters();
  drawSource();
  drawLine();
  drawReceived();
  drawSpectrum();
  drawHarmonics();

  requestAnimationFrame(animate);
}

updLabels();
requestAnimationFrame(animate);
</script>
</body>
</html>
