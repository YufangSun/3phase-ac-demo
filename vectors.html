<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dot Product &amp; Cross Product — Interactive Vector Demo</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:20px}
  h1{font-size:1.6em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.95em;text-align:center}
  canvas{display:block;border-radius:10px;cursor:grab}
  canvas:active{cursor:grabbing}
  .tabs{display:flex;gap:6px;margin:10px 0;flex-wrap:wrap;justify-content:center}
  .tab{padding:8px 18px;border-radius:8px;cursor:pointer;font-size:.88em;
    background:#161b22;border:1px solid #30363d;color:#8b949e;transition:.2s}
  .tab:hover{border-color:#58a6ff;color:#e6edf3}
  .tab.active{background:#1f6feb;border-color:#1f6feb;color:white;font-weight:bold}
  .eq-box{background:#161b22;border:1px solid #30363d;border-radius:10px;
    padding:10px 16px;margin:6px 0;max-width:960px;width:100%;text-align:center}
  .eq{font-size:1.1em;font-family:'Times New Roman',serif;color:#e0e0ff}
  .eq-desc{font-size:.8em;color:#7d8590;margin-top:3px;line-height:1.4}
  .row{display:flex;flex-wrap:wrap;gap:14px;justify-content:center;margin-top:10px;max-width:1100px;width:100%}
  .panel{background:#161b22;border-radius:12px;padding:14px;border:1px solid #30363d;flex:1;min-width:260px}
  .panel h2{font-size:.9em;color:#8b949e;margin-bottom:6px;text-align:center}
  .meters{display:flex;gap:10px;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .meter{background:#161b22;border:1px solid #30363d;border-radius:8px;padding:5px 12px;text-align:center;min-width:100px}
  .meter .ml{font-size:.7em;color:#8b949e}
  .meter .mv{font-size:.95em;font-weight:bold;font-family:'Courier New',monospace}
  .controls{display:flex;flex-wrap:wrap;gap:12px;margin-top:10px;justify-content:center;align-items:center}
  .cg{display:flex;align-items:center;gap:5px}
  .cg label{font-size:.8em;color:#8b949e;white-space:nowrap}
  input[type="range"]{width:90px;accent-color:#f78166}
  .val{font-size:.8em;color:#f78166;min-width:32px}
  button{background:#238636;color:white;border:none;padding:6px 16px;border-radius:6px;
    cursor:pointer;font-size:.85em;transition:.2s}
  button:hover{background:#2ea043}
  button.sec{background:#30363d}
  button.sec:hover{background:#484f58}
  .legend{display:flex;gap:14px;justify-content:center;margin:6px 0;flex-wrap:wrap}
  .legend-item{display:flex;align-items:center;gap:4px;font-size:.78em}
  .legend-dot{width:9px;height:9px;border-radius:50%}
  .info{max-width:1100px;width:100%;background:#161b22;border-radius:12px;
    padding:14px 18px;border:1px solid #30363d;margin-top:14px;font-size:.85em;line-height:1.6;color:#8b949e}
  .info strong{color:#e0e0ff}
  .info code{color:#f78166;background:#21262d;padding:1px 4px;border-radius:3px}
  a{color:#58a6ff}
  .hint{font-size:.78em;color:#484f58;margin-top:4px;text-align:center}
</style>
</head>
<body>

<h1>Dot Product &amp; Cross Product</h1>
<p class="subtitle">Drag the vector tips to explore — see geometry, projections, and areas update in real time</p>

<div class="tabs">
  <div class="tab active" data-tab="0">Dot Product (2D)</div>
  <div class="tab" data-tab="1">Cross Product (2D→scalar)</div>
  <div class="tab" data-tab="2">Both Together (2D)</div>
  <div class="tab" data-tab="3">Cross Product (3D)</div>
</div>

<div id="eqBox" class="eq-box">
  <div class="eq" id="eqText"></div>
  <div class="eq-desc" id="eqDesc"></div>
</div>

<canvas id="mainCanvas" width="1060" height="520"></canvas>
<div class="hint">Click and drag the colored circles at the vector tips to move them</div>

<div id="legendBox" class="legend"></div>
<div id="meterBox" class="meters"></div>

<div class="row">
  <div class="panel">
    <h2 id="ch1Title">Dot Product vs Angle</h2>
    <canvas id="chart1" width="520" height="200"></canvas>
  </div>
  <div class="panel">
    <h2 id="ch2Title">Cross Product vs Angle</h2>
    <canvas id="chart2" width="520" height="200"></canvas>
  </div>
</div>

<div class="controls">
  <div class="cg">
    <label>|A|:</label>
    <input type="range" id="magA" min="0.5" max="3" step="0.1" value="1.5">
    <span class="val" id="magAVal">1.5</span>
  </div>
  <div class="cg">
    <label>|B|:</label>
    <input type="range" id="magB" min="0.5" max="3" step="0.1" value="1.2">
    <span class="val" id="magBVal">1.2</span>
  </div>
  <div class="cg">
    <label>θ (angle):</label>
    <input type="range" id="angleSlider" min="0" max="360" step="1" value="45">
    <span class="val" id="angleVal">45°</span>
  </div>
  <button id="resetBtn" class="sec">Reset</button>
  <button id="animBtn">Animate θ</button>
</div>

<div class="info">
  <strong>Dot Product</strong> <code>A·B = |A||B|cos θ = A_xB_x + A_yB_y + A_zB_z</code><br>
  A <em>scalar</em> measuring how much two vectors align. Positive when same direction, zero when perpendicular, negative when opposite.
  Geometrically: projection of A onto B times |B| (or vice versa).
  <br><br>
  <strong>Cross Product</strong> <code>A×B = |A||B|sin θ  n̂</code><br>
  A <em>vector</em> perpendicular to both A and B. Its magnitude equals the area of the parallelogram formed by A and B.
  Direction follows the right-hand rule. In 2D, only the z-component is nonzero: <code>A_xB_y − A_yB_x</code>.
  <br><br>
  <strong>Key relationships:</strong> <code>(A·B)² + |A×B|² = |A|²|B|²</code> &nbsp; (cos²θ + sin²θ = 1)
  <br><br>
  <a href="index.html">← All Demos</a> ·
  <a href="maxwell.html">Maxwell's Equations</a> ·
  <a href="poynting.html">Poynting Theorem</a> ·
  <a href="phasor-transform.html">Phasor Transform</a> ·
  <a href="sawtooth-transmission.html">Sawtooth Transmission</a>
</div>

<script>
const mainC=document.getElementById('mainCanvas');
const c1C=document.getElementById('chart1');
const c2C=document.getElementById('chart2');
const mCtx=mainC.getContext('2d');
const c1Ctx=c1C.getContext('2d');
const c2Ctx=c2C.getContext('2d');

let currentTab=0;
let animating=false, animTime=0;

// Vector state (in grid units, origin at center)
let A={x:1.5,y:0.5}, B={x:0.5,y:1.3};
// 3D vectors
let A3={x:1.2,y:0.8,z:0.5}, B3={x:-0.5,y:1,z:0.8};
let drag=null; // 'A','B','A3','B3' or null

const magASlider=document.getElementById('magA');
const magBSlider=document.getElementById('magB');
const angleSlider=document.getElementById('angleSlider');

// Slider sync
function syncFromSliders(){
  const mA=parseFloat(magASlider.value);
  const mB=parseFloat(magBSlider.value);
  const th=parseFloat(angleSlider.value)*Math.PI/180;
  const angA=Math.atan2(A.y,A.x);
  A={x:mA*Math.cos(angA),y:mA*Math.sin(angA)};
  B={x:mB*Math.cos(angA+th),y:mB*Math.sin(angA+th)};
}

function syncToSliders(){
  const mA=Math.sqrt(A.x*A.x+A.y*A.y);
  const mB=Math.sqrt(B.x*B.x+B.y*B.y);
  let th=Math.atan2(B.y,B.x)-Math.atan2(A.y,A.x);
  if(th<0)th+=Math.PI*2;
  magASlider.value=mA.toFixed(1);magBSlider.value=mB.toFixed(1);
  angleSlider.value=Math.round(th*180/Math.PI);
  document.getElementById('magAVal').textContent=mA.toFixed(1);
  document.getElementById('magBVal').textContent=mB.toFixed(1);
  document.getElementById('angleVal').textContent=Math.round(th*180/Math.PI)+'°';
}

[magASlider,magBSlider,angleSlider].forEach(s=>{
  s.oninput=()=>{
    document.getElementById(s.id+'Val').textContent=
      s.id==='angleSlider'?s.value+'°':parseFloat(s.value).toFixed(1);
    syncFromSliders();
  };
});

document.getElementById('resetBtn').onclick=()=>{
  A={x:1.5,y:0.5};B={x:0.5,y:1.3};
  A3={x:1.2,y:0.8,z:0.5};B3={x:-0.5,y:1,z:0.8};
  animating=false;document.getElementById('animBtn').textContent='Animate θ';
  syncToSliders();
};

document.getElementById('animBtn').onclick=function(){
  animating=!animating;
  this.textContent=animating?'Stop':'Animate θ';
};

// Tab switching
const tabInfo=[
  {eq:'A · B = |A||B| cos θ = A<sub>x</sub>B<sub>x</sub> + A<sub>y</sub>B<sub>y</sub>',
   desc:'Scalar result. Equals the signed length of the projection of A onto B, times |B|. Drag vectors to see!',
   legend:[['#f97583','Vector A'],['#79c0ff','Vector B'],['#7ee787','Projection of A onto B'],['#ffa657','A·B (scalar)']]},
  {eq:'A × B = (A<sub>x</sub>B<sub>y</sub> − A<sub>y</sub>B<sub>x</sub>) ẑ = |A||B| sin θ  ẑ',
   desc:'In 2D the cross product is a scalar (z-component). Its absolute value = area of the parallelogram spanned by A and B.',
   legend:[['#f97583','Vector A'],['#79c0ff','Vector B'],['#d2a8ff','Parallelogram area'],['#ffa657','A×B (z-component)']]},
  {eq:'A·B = |A||B|cosθ  &nbsp;&nbsp;  |A×B| = |A||B|sinθ  &nbsp;&nbsp;  (A·B)² + |A×B|² = |A|²|B|²',
   desc:'Dot and cross product together: cos²θ + sin²θ = 1 visualized as projection + parallelogram.',
   legend:[['#f97583','Vector A'],['#79c0ff','Vector B'],['#7ee787','Projection (dot)'],['#d2a8ff','Parallelogram (cross)'],['#ffa657','Angle θ']]},
  {eq:'A × B = (A<sub>y</sub>B<sub>z</sub>−A<sub>z</sub>B<sub>y</sub>, A<sub>z</sub>B<sub>x</sub>−A<sub>x</sub>B<sub>z</sub>, A<sub>x</sub>B<sub>y</sub>−A<sub>y</sub>B<sub>x</sub>)',
   desc:'In 3D the cross product is a vector perpendicular to both A and B, with magnitude = parallelogram area. Direction by right-hand rule.',
   legend:[['#f97583','Vector A'],['#79c0ff','Vector B'],['#ffa657','A×B (result vector)'],['#d2a8ff','Parallelogram']]},
];

document.querySelectorAll('.tab').forEach(t=>{
  t.onclick=()=>{
    currentTab=parseInt(t.dataset.tab);
    document.querySelectorAll('.tab').forEach((x,i)=>x.classList.toggle('active',i===currentTab));
    const d=tabInfo[currentTab];
    document.getElementById('eqText').innerHTML=d.eq;
    document.getElementById('eqDesc').textContent=d.desc;
    const lb=document.getElementById('legendBox');lb.innerHTML='';
    d.legend.forEach(([c,l])=>{lb.innerHTML+=`<div class="legend-item"><div class="legend-dot" style="background:${c}"></div> ${l}</div>`;});
  };
});

// Mouse/touch interaction
const scale=120; // pixels per unit
function toScreen(v,ox,oy){return{x:ox+v.x*scale,y:oy-v.y*scale};}
function fromScreen(sx,sy,ox,oy){return{x:(sx-ox)/scale,y:-(sy-oy)/scale};}

let origin={x:mainC.width/2,y:mainC.height/2};

function getMousePos(e){
  const r=mainC.getBoundingClientRect();
  const x=(e.clientX||e.touches?.[0]?.clientX||0)-r.left;
  const y=(e.clientY||e.touches?.[0]?.clientY||0)-r.top;
  return{x,y};
}

mainC.addEventListener('mousedown',e=>{
  const m=getMousePos(e);
  const ox=currentTab===3?mainC.width/2:mainC.width/2;
  const oy=currentTab===3?mainC.height/2+40:mainC.height/2+40;
  const as=toScreen(A,ox,oy);
  const bs=toScreen(B,ox,oy);
  if(Math.hypot(m.x-as.x,m.y-as.y)<18)drag='A';
  else if(Math.hypot(m.x-bs.x,m.y-bs.y)<18)drag='B';
});
mainC.addEventListener('mousemove',e=>{
  if(!drag)return;
  const m=getMousePos(e);
  const ox=mainC.width/2,oy=mainC.height/2+40;
  const v=fromScreen(m.x,m.y,ox,oy);
  // Clamp
  v.x=Math.max(-4,Math.min(4,v.x));
  v.y=Math.max(-3,Math.min(3,v.y));
  if(drag==='A')A=v;
  else if(drag==='B')B=v;
  syncToSliders();
});
mainC.addEventListener('mouseup',()=>{drag=null;});
mainC.addEventListener('mouseleave',()=>{drag=null;});

// Touch support
mainC.addEventListener('touchstart',e=>{e.preventDefault();
  const m=getMousePos(e);const ox=mainC.width/2,oy=mainC.height/2+40;
  const as=toScreen(A,ox,oy),bs=toScreen(B,ox,oy);
  if(Math.hypot(m.x-as.x,m.y-as.y)<25)drag='A';
  else if(Math.hypot(m.x-bs.x,m.y-bs.y)<25)drag='B';
},{passive:false});
mainC.addEventListener('touchmove',e=>{e.preventDefault();
  if(!drag)return;const m=getMousePos(e);const ox=mainC.width/2,oy=mainC.height/2+40;
  const v=fromScreen(m.x,m.y,ox,oy);v.x=Math.max(-4,Math.min(4,v.x));v.y=Math.max(-3,Math.min(3,v.y));
  if(drag==='A')A=v;else if(drag==='B')B=v;syncToSliders();
},{passive:false});
mainC.addEventListener('touchend',()=>{drag=null;});

/* ===== DRAWING ===== */
function drawArrow(ctx,x0,y0,x1,y1,color,lineW,headLen){
  lineW=lineW||3;headLen=headLen||12;
  const dx=x1-x0,dy=y1-y0,len=Math.sqrt(dx*dx+dy*dy);
  if(len<1)return;
  const ux=dx/len,uy=dy/len;
  ctx.strokeStyle=color;ctx.lineWidth=lineW;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(x0,y0);ctx.lineTo(x1-ux*headLen*0.5,y1-uy*headLen*0.5);ctx.stroke();
  ctx.fillStyle=color;ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x1-ux*headLen+uy*headLen*0.35,y1-uy*headLen-ux*headLen*0.35);
  ctx.lineTo(x1-ux*headLen-uy*headLen*0.35,y1-uy*headLen+ux*headLen*0.35);
  ctx.closePath();ctx.fill();
}

function drawHandle(ctx,x,y,color){
  ctx.beginPath();ctx.arc(x,y,8,0,Math.PI*2);
  ctx.fillStyle=color;ctx.fill();
  ctx.strokeStyle='#0d1117';ctx.lineWidth=2;ctx.stroke();
}

function drawGrid2D(ctx,W,H,ox,oy){
  ctx.strokeStyle='#ffffff06';ctx.lineWidth=1;
  for(let gx=-5;gx<=5;gx++){
    const sx=ox+gx*scale;
    ctx.beginPath();ctx.moveTo(sx,0);ctx.lineTo(sx,H);ctx.stroke();
  }
  for(let gy=-4;gy<=4;gy++){
    const sy=oy-gy*scale;
    ctx.beginPath();ctx.moveTo(0,sy);ctx.lineTo(W,sy);ctx.stroke();
  }
  // Axes
  ctx.strokeStyle='#ffffff15';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.moveTo(0,oy);ctx.lineTo(W,oy);ctx.stroke();
  ctx.beginPath();ctx.moveTo(ox,0);ctx.lineTo(ox,H);ctx.stroke();

  ctx.fillStyle='#484f58';ctx.font='10px sans-serif';
  ctx.textAlign='center';ctx.fillText('x',W-10,oy-8);
  ctx.textAlign='right';ctx.fillText('y',ox-8,15);
}

function drawAngleArc(ctx,ox,oy,a1,a2,r,color){
  ctx.strokeStyle=color;ctx.lineWidth=2;
  ctx.beginPath();ctx.arc(ox,oy,r,-a1,-a2,a2>a1);ctx.stroke();
  // Label
  const mid=(a1+a2)/2;
  ctx.fillStyle=color;ctx.font='bold 13px sans-serif';ctx.textAlign='center';
  ctx.fillText('θ',ox+Math.cos(-mid)*(r+14),oy+Math.sin(-mid)*(r+14)+4);
}

/* ===== TAB 0: DOT PRODUCT ===== */
function drawDot(){
  const W=mainC.width,H=mainC.height;
  const ox=W/2,oy=H/2+40;
  mCtx.clearRect(0,0,W,H);
  drawGrid2D(mCtx,W,H,ox,oy);

  const as=toScreen(A,ox,oy),bs=toScreen(B,ox,oy);
  const magA=Math.sqrt(A.x*A.x+A.y*A.y);
  const magB=Math.sqrt(B.x*B.x+B.y*B.y);
  const dot=A.x*B.x+A.y*B.y;
  const angA=Math.atan2(A.y,A.x),angB=Math.atan2(B.y,B.x);
  let theta=angB-angA;if(theta<0)theta+=Math.PI*2;if(theta>Math.PI)theta=Math.PI*2-theta;
  const cosT=magA>0.01&&magB>0.01?dot/(magA*magB):0;

  // Projection of A onto B direction
  const projScalar=magB>0.01?dot/magB:0;
  const bHat={x:magB>0.01?B.x/magB:0,y:magB>0.01?B.y/magB:0};
  const proj={x:bHat.x*projScalar,y:bHat.y*projScalar};
  const projS=toScreen(proj,ox,oy);

  // Projection shaded region
  mCtx.fillStyle='#7ee78718';
  mCtx.beginPath();
  mCtx.moveTo(ox,oy);mCtx.lineTo(projS.x,projS.y);mCtx.lineTo(as.x,as.y);mCtx.closePath();
  mCtx.fill();

  // Projection line (A onto B)
  mCtx.strokeStyle='#7ee787';mCtx.lineWidth=3;mCtx.shadowColor='#7ee787';mCtx.shadowBlur=6;
  mCtx.beginPath();mCtx.moveTo(ox,oy);mCtx.lineTo(projS.x,projS.y);mCtx.stroke();
  mCtx.shadowBlur=0;

  // Dashed perpendicular from A tip to projection
  mCtx.strokeStyle='#7ee78750';mCtx.lineWidth=1.5;mCtx.setLineDash([5,5]);
  mCtx.beginPath();mCtx.moveTo(as.x,as.y);mCtx.lineTo(projS.x,projS.y);mCtx.stroke();
  mCtx.setLineDash([]);

  // Right angle marker
  if(Math.abs(projScalar)>0.1){
    const perpLen=8;
    const pDir={x:as.x-projS.x,y:as.y-projS.y};
    const pMag=Math.sqrt(pDir.x*pDir.x+pDir.y*pDir.y);
    if(pMag>5){
      const pu={x:pDir.x/pMag*perpLen,y:pDir.y/pMag*perpLen};
      const bu={x:(projS.x-ox),y:(projS.y-oy)};
      const bm=Math.sqrt(bu.x*bu.x+bu.y*bu.y);
      if(bm>5){
        const bun={x:-bu.x/bm*perpLen,y:-bu.y/bm*perpLen};
        mCtx.strokeStyle='#7ee78780';mCtx.lineWidth=1.5;
        mCtx.beginPath();
        mCtx.moveTo(projS.x+pu.x,projS.y+pu.y);
        mCtx.lineTo(projS.x+pu.x+bun.x,projS.y+pu.y+bun.y);
        mCtx.lineTo(projS.x+bun.x,projS.y+bun.y);
        mCtx.stroke();
      }
    }
  }

  // Angle arc
  drawAngleArc(mCtx,ox,oy,angA,angB,40,'#ffa657');

  // Vectors
  drawArrow(mCtx,ox,oy,as.x,as.y,'#f97583',3.5);
  drawArrow(mCtx,ox,oy,bs.x,bs.y,'#79c0ff',3.5);
  drawHandle(mCtx,as.x,as.y,'#f97583');
  drawHandle(mCtx,bs.x,bs.y,'#79c0ff');

  // Labels on vectors
  mCtx.font='bold 14px sans-serif';mCtx.textAlign='center';
  mCtx.fillStyle='#f97583';mCtx.fillText('A',(ox+as.x)/2-15,(oy+as.y)/2-10);
  mCtx.fillStyle='#79c0ff';mCtx.fillText('B',(ox+bs.x)/2+15,(oy+bs.y)/2-10);

  // Projection label
  mCtx.fillStyle='#7ee787';mCtx.font='11px sans-serif';
  mCtx.fillText('proj_B(A) = '+projScalar.toFixed(2),(ox+projS.x)/2,Math.min(oy-10,(oy+projS.y)/2+20));

  // Result box
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';mCtx.lineWidth=1;
  mCtx.beginPath();mCtx.roundRect(20,15,320,110,8);mCtx.fill();mCtx.stroke();
  mCtx.fillStyle='#ffa657';mCtx.font='bold 14px sans-serif';mCtx.textAlign='left';
  mCtx.fillText('A · B = '+dot.toFixed(3),35,40);
  mCtx.fillStyle='#8b949e';mCtx.font='12px sans-serif';
  mCtx.fillText(`= |A|·|B|·cosθ = ${magA.toFixed(2)}×${magB.toFixed(2)}×${cosT.toFixed(3)}`,35,62);
  mCtx.fillText(`= A_x·B_x + A_y·B_y = ${A.x.toFixed(2)}×${B.x.toFixed(2)} + ${A.y.toFixed(2)}×${B.y.toFixed(2)}`,35,82);
  mCtx.fillText(`θ = ${(theta*180/Math.PI).toFixed(1)}°   cos θ = ${cosT.toFixed(3)}`,35,102);

  // Interpretation
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';
  mCtx.beginPath();mCtx.roundRect(20,H-55,300,42,8);mCtx.fill();mCtx.stroke();
  mCtx.fillStyle=dot>0.01?'#7ee787':dot<-0.01?'#f97583':'#ffa657';
  mCtx.font='bold 12px sans-serif';mCtx.textAlign='left';
  const interp=dot>0.01?'Vectors point in similar directions (0°<θ<90°)':
    dot<-0.01?'Vectors point in opposite directions (90°<θ<180°)':
    'Vectors are perpendicular (θ = 90°)';
  mCtx.fillText(interp,35,H-37);
  mCtx.fillStyle='#8b949e';mCtx.font='10px sans-serif';
  mCtx.fillText(dot>0.01?'A·B > 0':dot<-0.01?'A·B < 0':'A·B = 0',35,H-22);

  updateMeters(magA,magB,theta,dot,A.x*B.y-A.y*B.x);
}

/* ===== TAB 1: CROSS PRODUCT 2D ===== */
function drawCross2D(){
  const W=mainC.width,H=mainC.height;
  const ox=W/2,oy=H/2+40;
  mCtx.clearRect(0,0,W,H);
  drawGrid2D(mCtx,W,H,ox,oy);

  const as=toScreen(A,ox,oy),bs=toScreen(B,ox,oy);
  const magA=Math.sqrt(A.x*A.x+A.y*A.y);
  const magB=Math.sqrt(B.x*B.x+B.y*B.y);
  const cross=A.x*B.y-A.y*B.x;
  const angA=Math.atan2(A.y,A.x),angB=Math.atan2(B.y,B.x);
  let theta=angB-angA;

  // Parallelogram
  const abS=toScreen({x:A.x+B.x,y:A.y+B.y},ox,oy);
  mCtx.fillStyle=cross>0?'rgba(210,168,255,0.12)':'rgba(210,168,255,0.12)';
  mCtx.strokeStyle='#d2a8ff40';mCtx.lineWidth=1.5;
  mCtx.beginPath();
  mCtx.moveTo(ox,oy);mCtx.lineTo(as.x,as.y);mCtx.lineTo(abS.x,abS.y);mCtx.lineTo(bs.x,bs.y);
  mCtx.closePath();mCtx.fill();mCtx.stroke();

  // Parallelogram dashed sides
  mCtx.setLineDash([5,5]);mCtx.strokeStyle='#d2a8ff30';
  mCtx.beginPath();mCtx.moveTo(as.x,as.y);mCtx.lineTo(abS.x,abS.y);mCtx.stroke();
  mCtx.beginPath();mCtx.moveTo(bs.x,bs.y);mCtx.lineTo(abS.x,abS.y);mCtx.stroke();
  mCtx.setLineDash([]);

  // Area label in parallelogram
  mCtx.fillStyle='#d2a8ff';mCtx.font='bold 13px sans-serif';mCtx.textAlign='center';
  const areaCenter={x:(ox+as.x+bs.x+abS.x)/4,y:(oy+as.y+bs.y+abS.y)/4};
  mCtx.fillText('Area = |A×B|',areaCenter.x,areaCenter.y-8);
  mCtx.fillText('= '+Math.abs(cross).toFixed(3),areaCenter.x,areaCenter.y+10);

  // Height line (perpendicular distance)
  if(magB>0.1){
    const h=Math.abs(cross)/magB;
    const bHat={x:B.x/magB,y:B.y/magB};
    const projA=A.x*bHat.x+A.y*bHat.y;
    const foot={x:bHat.x*projA,y:bHat.y*projA};
    const footS=toScreen(foot,ox,oy);
    mCtx.strokeStyle='#ffa65760';mCtx.lineWidth=1.5;mCtx.setLineDash([4,4]);
    mCtx.beginPath();mCtx.moveTo(as.x,as.y);mCtx.lineTo(footS.x,footS.y);mCtx.stroke();
    mCtx.setLineDash([]);
    mCtx.fillStyle='#ffa657';mCtx.font='10px sans-serif';
    mCtx.fillText('h='+h.toFixed(2),(as.x+footS.x)/2+10,(as.y+footS.y)/2);
  }

  // Angle arc
  drawAngleArc(mCtx,ox,oy,angA,angB,35,'#ffa657');

  // Cross product direction indicator (z-axis)
  const zDir=cross>0?'⊙ (out)':'⊗ (in)';
  mCtx.fillStyle='#ffa657';mCtx.font='bold 16px sans-serif';mCtx.textAlign='center';
  mCtx.fillText(cross>0?'⊙':'⊗',ox+5,oy-5);

  // Vectors
  drawArrow(mCtx,ox,oy,as.x,as.y,'#f97583',3.5);
  drawArrow(mCtx,ox,oy,bs.x,bs.y,'#79c0ff',3.5);
  drawHandle(mCtx,as.x,as.y,'#f97583');
  drawHandle(mCtx,bs.x,bs.y,'#79c0ff');

  mCtx.font='bold 14px sans-serif';
  mCtx.fillStyle='#f97583';mCtx.fillText('A',(ox+as.x)/2-15,(oy+as.y)/2-10);
  mCtx.fillStyle='#79c0ff';mCtx.fillText('B',(ox+bs.x)/2+15,(oy+bs.y)/2-10);

  // Result box
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';mCtx.lineWidth=1;
  mCtx.beginPath();mCtx.roundRect(20,15,350,110,8);mCtx.fill();mCtx.stroke();
  const sinT=magA>0.01&&magB>0.01?cross/(magA*magB):0;
  mCtx.fillStyle='#ffa657';mCtx.font='bold 14px sans-serif';mCtx.textAlign='left';
  mCtx.fillText('A × B = '+cross.toFixed(3)+' ẑ',35,40);
  mCtx.fillStyle='#8b949e';mCtx.font='12px sans-serif';
  mCtx.fillText(`= |A|·|B|·sinθ = ${magA.toFixed(2)}×${magB.toFixed(2)}×${sinT.toFixed(3)}`,35,62);
  mCtx.fillText(`= A_x·B_y − A_y·B_x = ${A.x.toFixed(2)}×${B.y.toFixed(2)} − ${A.y.toFixed(2)}×${B.x.toFixed(2)}`,35,82);
  mCtx.fillText(`|A×B| = parallelogram area = ${Math.abs(cross).toFixed(3)}`,35,102);

  // Direction hint
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';
  mCtx.beginPath();mCtx.roundRect(20,H-55,320,42,8);mCtx.fill();mCtx.stroke();
  mCtx.fillStyle=cross>0.01?'#7ee787':cross<-0.01?'#f97583':'#ffa657';
  mCtx.font='bold 12px sans-serif';mCtx.textAlign='left';
  const interp=cross>0.01?'A×B points OUT of screen (+z) — A to B is counter-clockwise':
    cross<-0.01?'A×B points INTO screen (−z) — A to B is clockwise':
    'A×B = 0 — vectors are parallel (sinθ = 0)';
  mCtx.fillText(interp,35,H-37);

  const dot=A.x*B.x+A.y*B.y;
  updateMeters(magA,magB,Math.abs(Math.asin(Math.max(-1,Math.min(1,sinT)))),dot,cross);
}

/* ===== TAB 2: BOTH ===== */
function drawBoth(){
  const W=mainC.width,H=mainC.height;
  const ox=W/2,oy=H/2+40;
  mCtx.clearRect(0,0,W,H);
  drawGrid2D(mCtx,W,H,ox,oy);

  const as=toScreen(A,ox,oy),bs=toScreen(B,ox,oy);
  const magA=Math.sqrt(A.x*A.x+A.y*A.y);
  const magB=Math.sqrt(B.x*B.x+B.y*B.y);
  const dot=A.x*B.x+A.y*B.y;
  const cross=A.x*B.y-A.y*B.x;
  const angA=Math.atan2(A.y,A.x),angB=Math.atan2(B.y,B.x);

  // Parallelogram (cross product)
  const abS=toScreen({x:A.x+B.x,y:A.y+B.y},ox,oy);
  mCtx.fillStyle='rgba(210,168,255,0.1)';mCtx.strokeStyle='#d2a8ff30';mCtx.lineWidth=1;
  mCtx.beginPath();
  mCtx.moveTo(ox,oy);mCtx.lineTo(as.x,as.y);mCtx.lineTo(abS.x,abS.y);mCtx.lineTo(bs.x,bs.y);
  mCtx.closePath();mCtx.fill();mCtx.stroke();

  // Projection (dot product)
  const projScalar=magB>0.01?dot/magB:0;
  const bHat={x:magB>0.01?B.x/magB:0,y:magB>0.01?B.y/magB:0};
  const proj={x:bHat.x*projScalar,y:bHat.y*projScalar};
  const projS=toScreen(proj,ox,oy);

  mCtx.strokeStyle='#7ee787';mCtx.lineWidth=4;mCtx.shadowColor='#7ee787';mCtx.shadowBlur=4;
  mCtx.beginPath();mCtx.moveTo(ox,oy);mCtx.lineTo(projS.x,projS.y);mCtx.stroke();
  mCtx.shadowBlur=0;

  mCtx.strokeStyle='#7ee78740';mCtx.lineWidth=1;mCtx.setLineDash([4,4]);
  mCtx.beginPath();mCtx.moveTo(as.x,as.y);mCtx.lineTo(projS.x,projS.y);mCtx.stroke();
  mCtx.setLineDash([]);

  // Angle arc
  drawAngleArc(mCtx,ox,oy,angA,angB,45,'#ffa657');

  // Vectors
  drawArrow(mCtx,ox,oy,as.x,as.y,'#f97583',3.5);
  drawArrow(mCtx,ox,oy,bs.x,bs.y,'#79c0ff',3.5);
  drawHandle(mCtx,as.x,as.y,'#f97583');
  drawHandle(mCtx,bs.x,bs.y,'#79c0ff');

  mCtx.font='bold 14px sans-serif';
  mCtx.fillStyle='#f97583';mCtx.fillText('A',(ox+as.x)/2-15,(oy+as.y)/2-10);
  mCtx.fillStyle='#79c0ff';mCtx.fillText('B',(ox+bs.x)/2+15,(oy+bs.y)/2-10);

  // Results
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';mCtx.lineWidth=1;
  mCtx.beginPath();mCtx.roundRect(20,15,300,75,8);mCtx.fill();mCtx.stroke();
  mCtx.fillStyle='#7ee787';mCtx.font='bold 13px sans-serif';mCtx.textAlign='left';
  mCtx.fillText('A · B = '+dot.toFixed(3)+'  (projection × |B|)',35,38);
  mCtx.fillStyle='#d2a8ff';
  mCtx.fillText('|A × B| = '+Math.abs(cross).toFixed(3)+'  (parallelogram area)',35,60);
  mCtx.fillStyle='#ffa657';mCtx.font='11px sans-serif';
  mCtx.fillText(`(A·B)² + |A×B|² = ${(dot*dot+cross*cross).toFixed(3)} = |A|²|B|² = ${(magA*magA*magB*magB).toFixed(3)}`,35,80);

  // Pythag identity visual (right side)
  const bx=W-280,by=80,bw=240,bh=20;
  const total=magA*magA*magB*magB;
  const dotFrac=total>0?dot*dot/total:0;
  const crossFrac=total>0?cross*cross/total:0;
  mCtx.fillStyle='#161b22';mCtx.beginPath();mCtx.roundRect(bx-10,by-20,bw+20,70,8);mCtx.fill();
  mCtx.fillStyle='#7ee78780';mCtx.fillRect(bx,by,bw*dotFrac,bh);
  mCtx.fillStyle='#d2a8ff80';mCtx.fillRect(bx+bw*dotFrac,by,bw*crossFrac,bh);
  mCtx.strokeStyle='#484f58';mCtx.strokeRect(bx,by,bw,bh);
  mCtx.fillStyle='#e6edf3';mCtx.font='10px sans-serif';mCtx.textAlign='center';
  mCtx.fillText('cos²θ = '+(dotFrac).toFixed(2),bx+bw*dotFrac/2,by+14);
  mCtx.fillText('sin²θ = '+(crossFrac).toFixed(2),bx+bw*dotFrac+bw*crossFrac/2,by+14);
  mCtx.fillStyle='#8b949e';mCtx.fillText('cos²θ + sin²θ = 1',bx+bw/2,by+38);

  let theta=angB-angA;if(theta<0)theta+=Math.PI*2;if(theta>Math.PI)theta=Math.PI*2-theta;
  updateMeters(magA,magB,theta,dot,cross);
}

/* ===== TAB 3: CROSS PRODUCT 3D ===== */
function drawCross3D(){
  const W=mainC.width,H=mainC.height;
  const ox=W/2,oy=H/2+60;
  mCtx.clearRect(0,0,W,H);

  // 3D -> 2D isometric projection
  const rotY=time*0.3;
  function proj3D(v){
    const cosR=Math.cos(rotY),sinR=Math.sin(rotY);
    const rx=v.x*cosR-v.z*sinR;
    const rz=v.x*sinR+v.z*cosR;
    return{x:ox+(rx-rz*0.5)*scale,y:oy-(v.y-rz*0.15)*scale};
  }

  // Draw 3D axes
  const axLen=2;
  [{v:{x:axLen,y:0,z:0},c:'#f9758340',l:'x'},{v:{x:0,y:axLen,z:0},c:'#7ee78740',l:'y'},
   {v:{x:0,y:0,z:axLen},c:'#79c0ff40',l:'z'}].forEach(({v,c,l})=>{
    const p=proj3D(v);const o=proj3D({x:0,y:0,z:0});
    mCtx.strokeStyle=c;mCtx.lineWidth=1.5;mCtx.setLineDash([4,4]);
    mCtx.beginPath();mCtx.moveTo(o.x,o.y);mCtx.lineTo(p.x,p.y);mCtx.stroke();mCtx.setLineDash([]);
    mCtx.fillStyle=c;mCtx.font='12px sans-serif';mCtx.textAlign='center';
    mCtx.fillText(l,p.x+10,p.y);
  });

  // Cross product C = A × B
  const C={
    x:A3.y*B3.z-A3.z*B3.y,
    y:A3.z*B3.x-A3.x*B3.z,
    z:A3.x*B3.y-A3.y*B3.x
  };
  const magC=Math.sqrt(C.x*C.x+C.y*C.y+C.z*C.z);
  const dot3=A3.x*B3.x+A3.y*B3.y+A3.z*B3.z;
  const magA3=Math.sqrt(A3.x*A3.x+A3.y*A3.y+A3.z*A3.z);
  const magB3=Math.sqrt(B3.x*B3.x+B3.y*B3.y+B3.z*B3.z);

  // Parallelogram
  const pA=proj3D(A3),pB=proj3D(B3);
  const pAB=proj3D({x:A3.x+B3.x,y:A3.y+B3.y,z:A3.z+B3.z});
  const pO=proj3D({x:0,y:0,z:0});
  const pC=proj3D(C);

  mCtx.fillStyle='rgba(210,168,255,0.1)';mCtx.strokeStyle='#d2a8ff30';mCtx.lineWidth=1;
  mCtx.beginPath();
  mCtx.moveTo(pO.x,pO.y);mCtx.lineTo(pA.x,pA.y);mCtx.lineTo(pAB.x,pAB.y);mCtx.lineTo(pB.x,pB.y);
  mCtx.closePath();mCtx.fill();mCtx.stroke();

  // Vectors
  drawArrow(mCtx,pO.x,pO.y,pA.x,pA.y,'#f97583',3);
  drawArrow(mCtx,pO.x,pO.y,pB.x,pB.y,'#79c0ff',3);
  if(magC>0.01){
    drawArrow(mCtx,pO.x,pO.y,pC.x,pC.y,'#ffa657',4,14);
    // Glow
    mCtx.shadowColor='#ffa657';mCtx.shadowBlur=8;
    mCtx.strokeStyle='#ffa657';mCtx.lineWidth=2;
    mCtx.beginPath();mCtx.moveTo(pO.x,pO.y);mCtx.lineTo(pC.x,pC.y);mCtx.stroke();
    mCtx.shadowBlur=0;
  }

  // Labels
  mCtx.font='bold 14px sans-serif';
  mCtx.fillStyle='#f97583';mCtx.textAlign='center';mCtx.fillText('A',pA.x+12,pA.y-8);
  mCtx.fillStyle='#79c0ff';mCtx.fillText('B',pB.x+12,pB.y-8);
  mCtx.fillStyle='#ffa657';mCtx.fillText('A×B',pC.x+15,pC.y-8);

  // Perpendicularity indicators
  if(magC>0.1){
    mCtx.fillStyle='#8b949e';mCtx.font='11px sans-serif';mCtx.textAlign='center';
    mCtx.fillText('⊥ to both A and B',pC.x,pC.y+18);
  }

  // Result box
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';mCtx.lineWidth=1;
  mCtx.beginPath();mCtx.roundRect(20,15,420,130,8);mCtx.fill();mCtx.stroke();
  mCtx.fillStyle='#ffa657';mCtx.font='bold 14px sans-serif';mCtx.textAlign='left';
  mCtx.fillText(`A × B = (${C.x.toFixed(2)}, ${C.y.toFixed(2)}, ${C.z.toFixed(2)})`,35,40);
  mCtx.fillStyle='#8b949e';mCtx.font='12px sans-serif';
  mCtx.fillText(`|A×B| = ${magC.toFixed(3)}  (parallelogram area)`,35,62);
  mCtx.fillText(`A = (${A3.x.toFixed(2)}, ${A3.y.toFixed(2)}, ${A3.z.toFixed(2)})  |A| = ${magA3.toFixed(2)}`,35,84);
  mCtx.fillText(`B = (${B3.x.toFixed(2)}, ${B3.y.toFixed(2)}, ${B3.z.toFixed(2)})  |B| = ${magB3.toFixed(2)}`,35,104);
  mCtx.fillText(`A · B = ${dot3.toFixed(3)}   A·(A×B) = ${(A3.x*C.x+A3.y*C.y+A3.z*C.z).toFixed(6)} ≈ 0  ✓`,35,124);

  // Rotating hint
  mCtx.fillStyle='#484f58';mCtx.font='10px sans-serif';mCtx.textAlign='center';
  mCtx.fillText('Auto-rotating to show 3D perspective. Use sliders to change vectors.',W/2,H-10);

  // Right-hand rule reminder
  mCtx.fillStyle='#161b22';mCtx.strokeStyle='#30363d';
  mCtx.beginPath();mCtx.roundRect(W-250,15,230,50,8);mCtx.fill();mCtx.stroke();
  mCtx.fillStyle='#ffa657';mCtx.font='bold 11px sans-serif';mCtx.textAlign='left';
  mCtx.fillText('Right-hand rule:',W-240,35);
  mCtx.fillStyle='#8b949e';mCtx.font='10px sans-serif';
  mCtx.fillText('Fingers curl A→B, thumb = A×B',W-240,52);

  const theta=magA3>0.01&&magB3>0.01?Math.acos(Math.max(-1,Math.min(1,dot3/(magA3*magB3)))):0;
  updateMeters(magA3,magB3,theta,dot3,magC);
}

/* ===== METERS ===== */
function updateMeters(magA,magB,theta,dot,crossMag){
  const mb=document.getElementById('meterBox');
  mb.innerHTML='';
  const ms=[
    {l:'|A|',v:magA.toFixed(3),c:'#f97583'},
    {l:'|B|',v:magB.toFixed(3),c:'#79c0ff'},
    {l:'θ',v:(theta*180/Math.PI).toFixed(1)+'°',c:'#ffa657'},
    {l:'A · B',v:dot.toFixed(3),c:'#7ee787'},
    {l:currentTab===3?'|A×B|':'A×B (z)',v:(typeof crossMag==='number'?crossMag:0).toFixed(3),c:'#d2a8ff'},
    {l:'cos θ',v:Math.cos(theta).toFixed(3),c:'#8b949e'},
    {l:'sin θ',v:Math.sin(theta).toFixed(3),c:'#8b949e'},
  ];
  ms.forEach(m=>{
    mb.innerHTML+=`<div class="meter"><div class="ml">${m.l}</div><div class="mv" style="color:${m.c}">${m.v}</div></div>`;
  });
}

/* ===== CHARTS ===== */
function drawCharts(){
  const magA_=Math.sqrt(A.x*A.x+A.y*A.y);
  const magB_=Math.sqrt(B.x*B.x+B.y*B.y);
  const angA=Math.atan2(A.y,A.x),angB=Math.atan2(B.y,B.x);
  let curTheta=angB-angA;if(curTheta<0)curTheta+=Math.PI*2;

  document.getElementById('ch1Title').textContent='Dot product = |A||B|cos θ  vs θ';
  document.getElementById('ch2Title').textContent='|Cross product| = |A||B|sin θ  vs θ';

  const pad={l:45,r:15,t:15,b:25};

  [c1Ctx,c2Ctx].forEach((ctx,ci)=>{
    const c=ci===0?c1C:c2C;
    const W=c.width,H=c.height;
    const pW=W-pad.l-pad.r,pH=H-pad.t-pad.b;
    ctx.clearRect(0,0,W,H);

    // Grid
    ctx.strokeStyle='#ffffff08';ctx.lineWidth=1;
    for(let i=0;i<=4;i++){const y=pad.t+(i/4)*pH;
      ctx.beginPath();ctx.moveTo(pad.l,y);ctx.lineTo(pad.l+pW,y);ctx.stroke();}

    const midY=pad.t+pH/2;
    ctx.strokeStyle='#ffffff20';
    ctx.beginPath();ctx.moveTo(pad.l,midY);ctx.lineTo(pad.l+pW,midY);ctx.stroke();

    const maxVal=magA_*magB_*1.1;

    // Curve
    const color=ci===0?'#7ee787':'#d2a8ff';
    ctx.strokeStyle=color;ctx.lineWidth=2;ctx.beginPath();
    for(let i=0;i<=360;i++){
      const th=i*Math.PI/180;
      const v=ci===0?magA_*magB_*Math.cos(th):magA_*magB_*Math.sin(th);
      const x=pad.l+(i/360)*pW;
      const y=midY-(v/maxVal)*(pH/2*0.9);
      i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Fill positive region
    ctx.fillStyle=color+'15';ctx.beginPath();ctx.moveTo(pad.l,midY);
    for(let i=0;i<=360;i++){
      const th=i*Math.PI/180;
      const v=ci===0?magA_*magB_*Math.cos(th):magA_*magB_*Math.sin(th);
      if((ci===0&&v>0)||(ci===1&&v>0)){
        const x=pad.l+(i/360)*pW;const y=midY-(v/maxVal)*(pH/2*0.9);
        ctx.lineTo(x,y);
      } else {
        ctx.lineTo(pad.l+(i/360)*pW,midY);
      }
    }
    ctx.lineTo(pad.l+pW,midY);ctx.closePath();ctx.fill();

    // Current angle marker
    const curDeg=curTheta*180/Math.PI;
    const markerX=pad.l+(curDeg/360)*pW;
    const curVal=ci===0?magA_*magB_*Math.cos(curTheta):magA_*magB_*Math.sin(curTheta);
    const markerY=midY-(curVal/maxVal)*(pH/2*0.9);

    ctx.strokeStyle='#ffa65780';ctx.lineWidth=1;ctx.setLineDash([3,3]);
    ctx.beginPath();ctx.moveTo(markerX,pad.t);ctx.lineTo(markerX,pad.t+pH);ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath();ctx.arc(markerX,markerY,6,0,Math.PI*2);
    ctx.fillStyle=color;ctx.fill();ctx.strokeStyle='#fff';ctx.lineWidth=2;ctx.stroke();

    ctx.fillStyle=color;ctx.font='bold 11px sans-serif';ctx.textAlign='left';
    ctx.fillText((ci===0?'A·B=':'|A×B|=')+curVal.toFixed(2),markerX+10,markerY-8);

    // Axis labels
    ctx.fillStyle='#484f58';ctx.font='9px sans-serif';ctx.textAlign='center';
    ctx.fillText('0°',pad.l,pad.t+pH+14);
    ctx.fillText('90°',pad.l+pW/4,pad.t+pH+14);
    ctx.fillText('180°',pad.l+pW/2,pad.t+pH+14);
    ctx.fillText('270°',pad.l+3*pW/4,pad.t+pH+14);
    ctx.fillText('360°',pad.l+pW,pad.t+pH+14);
    ctx.fillText('θ →',pad.l+pW/2,H-3);

    // Special points
    if(ci===0){
      ctx.fillStyle='#7ee78760';ctx.font='9px sans-serif';
      ctx.fillText('max',pad.l+5,pad.t+10);ctx.fillText('0',pad.l+pW/4,midY-5);
      ctx.fillText('min',pad.l+pW/2+5,pad.t+pH-5);
    }
  });
}

/* ===== ANIMATION ===== */
function animate(ts){
  if(animating){
    const mA=parseFloat(magASlider.value);
    const mB=parseFloat(magBSlider.value);
    animTime+=0.008;
    const th=animTime%(Math.PI*2);
    const angA_=Math.atan2(A.y,A.x);
    A={x:mA*Math.cos(angA_),y:mA*Math.sin(angA_)};
    B={x:mB*Math.cos(angA_+th),y:mB*Math.sin(angA_+th)};
    syncToSliders();
  }

  switch(currentTab){
    case 0:drawDot();break;
    case 1:drawCross2D();break;
    case 2:drawBoth();break;
    case 3:drawCross3D();break;
  }
  drawCharts();
  requestAnimationFrame(animate);
}

// Initialize
document.querySelectorAll('.tab')[0].click();
syncToSliders();
requestAnimationFrame(animate);
</script>
</body>
</html>
