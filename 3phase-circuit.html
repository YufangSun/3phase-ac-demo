<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3-Phase AC Circuit Configurations</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{background:#0d1117;color:#e6edf3;font-family:'Segoe UI',system-ui,sans-serif;
    display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{font-size:1.5em;color:#e0e0ff}
  .subtitle{color:#7d8590;margin-bottom:10px;font-size:.92em;text-align:center;max-width:820px}

  .tabs{display:flex;gap:6px;margin:10px 0;flex-wrap:wrap;justify-content:center}
  .tab{padding:8px 18px;border-radius:8px;cursor:pointer;font-size:.88em;
    background:#161b22;border:1px solid #30363d;color:#8b949e;transition:.2s}
  .tab:hover{border-color:#58a6ff;color:#e6edf3}
  .tab.active{background:#1f6feb;border-color:#1f6feb;color:white;font-weight:bold}

  .main{max-width:960px;width:100%;margin-top:8px}
  .row{display:flex;gap:14px;flex-wrap:wrap;justify-content:center}
  .panel{background:#161b22;border-radius:12px;padding:16px;border:1px solid #30363d;margin-bottom:12px;flex:1;min-width:300px}
  .panel h2{font-size:.9em;color:#8b949e;margin-bottom:8px;text-align:center}
  canvas{display:block;margin:0 auto;border-radius:8px}

  .controls{display:flex;gap:14px;flex-wrap:wrap;justify-content:center;align-items:center;
    background:#161b22;border:1px solid #30363d;border-radius:10px;padding:10px 16px;
    margin-bottom:10px;max-width:960px;width:100%}
  .cg{display:flex;align-items:center;gap:6px}
  .cg label{font-size:.82em;color:#8b949e;white-space:nowrap}
  input[type="range"]{width:100px;accent-color:#58a6ff}
  .cv{font-size:.82em;color:#58a6ff;min-width:55px;font-family:'Courier New',monospace}

  .results{background:#161b22;border:1px solid #30363d;border-radius:10px;padding:14px 18px;
    margin-bottom:12px;max-width:960px;width:100%}
  .results h2{font-size:.9em;color:#8b949e;margin-bottom:8px;text-align:center}
  .res-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px}
  .res-item{background:#0d1117;border-radius:8px;padding:8px 12px;text-align:center}
  .res-label{font-size:.72em;color:#7d8590;margin-bottom:2px}
  .res-val{font-size:1.05em;font-family:'Courier New',monospace;font-weight:bold}

  .formula-box{background:#0d1117;border:1px solid #30363d;border-radius:8px;padding:10px 14px;
    margin-top:8px;font-size:.82em;color:#8b949e;line-height:1.7;text-align:center}
  .formula-box .f{color:#f78166;font-family:'Courier New',monospace}
  .formula-box .h{color:#e0e0ff;font-weight:bold}

  .info{max-width:960px;width:100%;background:#161b22;border-radius:12px;
    padding:14px 18px;border:1px solid #30363d;margin-top:10px;font-size:.84em;line-height:1.6;color:#8b949e}
  .info strong{color:#e0e0ff}
  a{color:#58a6ff}
  .hidden{display:none}
</style>
</head>
<body>

<h1>3-Phase AC Circuit Configurations</h1>
<p class="subtitle">Compare Y-Y, Y-Δ, Δ-Δ, and Δ-Y connections — voltage/current relationships, phasor diagrams, and power</p>

<div class="tabs">
  <div class="tab active" data-cfg="yy">Y – Y</div>
  <div class="tab" data-cfg="yd">Y – Δ</div>
  <div class="tab" data-cfg="dd">Δ – Δ</div>
  <div class="tab" data-cfg="dy">Δ – Y</div>
</div>

<div class="controls">
  <div class="cg">
    <label>V<sub>source</sub>:</label>
    <input type="range" id="sVmag" min="10" max="480" step="5" value="120">
    <span class="cv" id="sVmagV">120 V</span>
  </div>
  <div class="cg">
    <label>|Z<sub>load</sub>|:</label>
    <input type="range" id="sZmag" min="1" max="100" step="1" value="30">
    <span class="cv" id="sZmagV">30 Ω</span>
  </div>
  <div class="cg">
    <label>θ<sub>load</sub>:</label>
    <input type="range" id="sZang" min="-80" max="80" step="1" value="30">
    <span class="cv" id="sZangV">30°</span>
  </div>
  <div class="cg">
    <label>Freq:</label>
    <input type="range" id="sFreq" min="0.3" max="3" step="0.1" value="1">
    <span class="cv" id="sFreqV">1.0 Hz</span>
  </div>
</div>

<div class="results" id="resBox">
  <h2 id="resTitle">Y – Y Results</h2>
  <div class="res-grid" id="resGrid"></div>
  <div class="formula-box" id="formulaBox"></div>
</div>

<div class="main">
  <div class="row">
    <div class="panel">
      <h2>Circuit Diagram</h2>
      <canvas id="circuitCanvas" width="560" height="380"></canvas>
    </div>
    <div class="panel">
      <h2>Phasor Diagram</h2>
      <canvas id="phasorCanvas" width="340" height="320"></canvas>
    </div>
  </div>
  <div class="row">
    <div class="panel">
      <h2>Waveforms</h2>
      <canvas id="waveCanvas" width="920" height="240"></canvas>
    </div>
  </div>
</div>

<div class="info">
  <strong>Y (Star) connection:</strong> V<sub>line</sub> = √3 · V<sub>phase</sub>, I<sub>line</sub> = I<sub>phase</sub>.
  Neutral wire carries zero current in balanced system.<br>
  <strong>Δ (Delta) connection:</strong> V<sub>line</sub> = V<sub>phase</sub>, I<sub>line</sub> = √3 · I<sub>phase</sub>.
  No neutral wire needed.<br>
  <strong>Power:</strong> P = √3 · V<sub>L</sub> · I<sub>L</sub> · cos θ &nbsp;(same formula for all configs)<br><br>
  <a href="index.html">← All Demos</a> ·
  <a href="3phase-ac.html">3-Phase AC Power</a> ·
  <a href="phasor-transform.html">Phasor Transform</a> ·
  <a href="transformer.html">Transformer</a> ·
  <a href="mutual-inductance.html">Mutual Inductance</a>
</div>

<script>
// ── Config ──
let cfg = 'yy'; // 'yy','yd','dd','dy'
const sqrt3 = Math.sqrt(3);

const tabs = document.querySelectorAll('.tab');
tabs.forEach(t => t.addEventListener('click', () => {
  tabs.forEach(x => x.classList.remove('active'));
  t.classList.add('active');
  cfg = t.dataset.cfg;
  compute();
}));

// ── Sliders ──
const sVmag = document.getElementById('sVmag');
const sZmag = document.getElementById('sZmag');
const sZang = document.getElementById('sZang');
const sFreq = document.getElementById('sFreq');

sVmag.oninput = () => { document.getElementById('sVmagV').textContent = sVmag.value + ' V'; compute(); };
sZmag.oninput = () => { document.getElementById('sZmagV').textContent = sZmag.value + ' Ω'; compute(); };
sZang.oninput = () => { document.getElementById('sZangV').textContent = sZang.value + '°'; compute(); };
sFreq.oninput = () => { document.getElementById('sFreqV').textContent = (+sFreq.value).toFixed(1) + ' Hz'; };

// ── Canvases ──
const circuitC = document.getElementById('circuitCanvas');
const phasorC = document.getElementById('phasorCanvas');
const waveC = document.getElementById('waveCanvas');
const cCtx = circuitC.getContext('2d');
const pCtx = phasorC.getContext('2d');
const wCtx = waveC.getContext('2d');

const COLORS = {a:'#ff4466', b:'#44cc66', c:'#4488ff'};
const COLORSARR = ['#ff4466','#44cc66','#4488ff'];
const PHASE_OFF = [0, -2*Math.PI/3, -4*Math.PI/3];
const LABELS = ['A','B','C'];

// ── Computed values ──
let res = {};

function compute() {
  const Vs = +sVmag.value;   // source voltage (phase for Y, line for Δ)
  const Zm = +sZmag.value;
  const Za = +sZang.value * Math.PI / 180;
  const srcType = cfg[0]; // 'y' or 'd'
  const loadType = cfg[1]; // 'y' or 'd'

  // Source voltages
  let VpS, VlS; // phase and line voltages of source
  if (srcType === 'y') {
    VpS = Vs;
    VlS = Vs * sqrt3;
  } else {
    VlS = Vs;
    VpS = Vs; // Δ source: Vphase = Vline
  }

  // Load voltages
  let VpL, VlL; // phase and line voltages at load
  VlL = VlS; // line voltage same across (ideal, no line impedance)
  if (loadType === 'y') {
    VpL = VlL / sqrt3;
  } else {
    VpL = VlL;
  }

  // Load phase current
  const IpL = VpL / Zm;

  // Load line current
  let IlL;
  if (loadType === 'y') {
    IlL = IpL;
  } else {
    IlL = IpL * sqrt3;
  }

  // Source phase current
  let IpS;
  if (srcType === 'y') {
    IpS = IlL; // Y source: Iphase = Iline
  } else {
    IpS = IlL / sqrt3; // Δ source: Iphase = Iline/√3
  }

  // Power
  const PF = Math.cos(Za);
  const P = sqrt3 * VlL * IlL * PF;
  const Q = sqrt3 * VlL * IlL * Math.sin(Za);
  const S = sqrt3 * VlL * IlL;

  res = {
    srcType, loadType,
    VpS, VlS, VpL, VlL, IpL, IlL, IpS,
    Zm, Za, PF, P, Q, S, Vs
  };

  updateResults();
  drawCircuit();
  drawPhasors();
}

function fmtV(v) { return v < 10 ? v.toFixed(2) : v < 100 ? v.toFixed(1) : Math.round(v); }

function updateResults() {
  const names = {yy:'Y – Y', yd:'Y – Δ', dd:'Δ – Δ', dy:'Δ – Y'};
  document.getElementById('resTitle').textContent = names[cfg] + ' Results';

  const r = res;
  const items = [
    {label:'V<sub>L,source</sub> (line)', val: fmtV(r.VlS) + ' V', color:'#58a6ff'},
    {label:'V<sub>φ,source</sub> (phase)', val: fmtV(r.VpS) + ' V', color:'#58a6ff'},
    {label:'V<sub>L,load</sub> (line)', val: fmtV(r.VlL) + ' V', color:'#3fb950'},
    {label:'V<sub>φ,load</sub> (phase)', val: fmtV(r.VpL) + ' V', color:'#3fb950'},
    {label:'I<sub>line</sub>', val: fmtV(r.IlL) + ' A', color:'#f78166'},
    {label:'I<sub>φ,load</sub> (phase)', val: fmtV(r.IpL) + ' A', color:'#f78166'},
    {label:'I<sub>φ,source</sub> (phase)', val: fmtV(r.IpS) + ' A', color:'#f78166'},
    {label:'PF (cos θ)', val: r.PF.toFixed(3), color:'#d2a8ff'},
    {label:'P (active)', val: fmtV(r.P) + ' W', color:'#d29922'},
    {label:'Q (reactive)', val: fmtV(r.Q) + ' VAR', color:'#d29922'},
    {label:'S (apparent)', val: fmtV(r.S) + ' VA', color:'#d29922'},
  ];

  let html = '';
  items.forEach(it => {
    html += `<div class="res-item"><div class="res-label">${it.label}</div>` +
      `<div class="res-val" style="color:${it.color}">${it.val}</div></div>`;
  });
  document.getElementById('resGrid').innerHTML = html;

  // Formulas
  const s = res.srcType === 'y' ? 'Y' : 'Δ';
  const l = res.loadType === 'y' ? 'Y' : 'Δ';
  let f = `<span class="h">Source (${s}):</span> `;
  if (res.srcType === 'y') {
    f += `<span class="f">V<sub>L</sub> = √3 · V<sub>φ</sub> = √3 × ${fmtV(res.VpS)} = ${fmtV(res.VlS)} V</span>, `;
    f += `<span class="f">I<sub>φ</sub> = I<sub>line</sub> = ${fmtV(res.IpS)} A</span>`;
  } else {
    f += `<span class="f">V<sub>L</sub> = V<sub>φ</sub> = ${fmtV(res.VlS)} V</span>, `;
    f += `<span class="f">I<sub>line</sub> = √3 · I<sub>φ</sub> → I<sub>φ</sub> = ${fmtV(res.IlL)}/√3 = ${fmtV(res.IpS)} A</span>`;
  }
  f += `<br><span class="h">Load (${l}):</span> `;
  if (res.loadType === 'y') {
    f += `<span class="f">V<sub>φ</sub> = V<sub>L</sub>/√3 = ${fmtV(res.VlL)}/√3 = ${fmtV(res.VpL)} V</span>, `;
    f += `<span class="f">I<sub>φ</sub> = V<sub>φ</sub>/|Z| = ${fmtV(res.VpL)}/${res.Zm} = ${fmtV(res.IpL)} A</span>, `;
    f += `<span class="f">I<sub>line</sub> = I<sub>φ</sub> = ${fmtV(res.IlL)} A</span>`;
  } else {
    f += `<span class="f">V<sub>φ</sub> = V<sub>L</sub> = ${fmtV(res.VpL)} V</span>, `;
    f += `<span class="f">I<sub>φ</sub> = V<sub>φ</sub>/|Z| = ${fmtV(res.VpL)}/${res.Zm} = ${fmtV(res.IpL)} A</span>, `;
    f += `<span class="f">I<sub>line</sub> = √3 · I<sub>φ</sub> = ${fmtV(res.IlL)} A</span>`;
  }
  f += `<br><span class="h">Power:</span> <span class="f">P = √3 · ${fmtV(res.VlL)} · ${fmtV(res.IlL)} · cos(${(res.Za*180/Math.PI).toFixed(0)}°) = ${fmtV(res.P)} W</span>`;
  document.getElementById('formulaBox').innerHTML = f;
}

// ── Circuit Diagram (detailed) ──
function drawCircuit() {
  const W = circuitC.width, H = circuitC.height;
  const ctx = cCtx;
  ctx.clearRect(0, 0, W, H);

  const srcY = res.srcType === 'y';
  const ldY  = res.loadType === 'y';
  const pc = [COLORS.a, COLORS.b, COLORS.c];

  // Layout constants
  const cy  = 195;   // vertical center
  const sp  = 80;    // vertical spacing between phase lines
  const srcX = 120;  // source center x
  const ldX  = 440;  // load center x
  const lineL = 195; // line wire left x (source terminal)
  const lineR = 365; // line wire right x (load terminal)

  // ── Title labels ──
  ctx.font = 'bold 13px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#e6edf3';
  ctx.fillText(srcY ? 'Y Source' : 'Δ Source', srcX, 24);
  ctx.fillText(ldY ? 'Y Load' : 'Δ Load', ldX, 24);

  // ── Phase terminal positions ──
  const yA = cy - sp, yB = cy, yC = cy + sp;
  const ys = [yA, yB, yC];

  // ═══ Draw Source ═══
  if (srcY) {
    // Neutral point
    const nx = srcX - 55;
    // Draw three branches from neutral to terminals
    for (let i = 0; i < 3; i++) {
      const y = ys[i];
      // Wire from neutral to source symbol
      ctx.strokeStyle = pc[i]; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(nx, cy); ctx.lineTo(nx + 18, y); ctx.stroke();
      // AC source circle
      drawACSourceH(ctx, nx + 18, y, srcX + 30, y, pc[i]);
      // Wire from source to terminal
      ctx.beginPath(); ctx.moveTo(srcX + 30 + 14, y); ctx.lineTo(lineL, y); ctx.stroke();
      // Terminal dot
      drawDot(ctx, lineL, y, pc[i]);
      // + / − polarity
      ctx.fillStyle = pc[i]; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('+', nx + 28, y - 14); ctx.fillText('−', srcX + 20, y - 14);
      // Phase label at terminal
      ctx.font = 'bold 11px sans-serif';
      ctx.fillText(LABELS[i], lineL + 1, y - 10);
    }
    // Neutral dot & label
    drawDot(ctx, nx, cy, '#8b949e');
    ctx.fillStyle = '#8b949e'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'right';
    ctx.fillText('N', nx - 8, cy + 4);
    // Neutral wire down (dashed)
    ctx.strokeStyle = '#8b949e40'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.moveTo(nx, cy); ctx.lineTo(nx, cy + sp + 30); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#8b949e'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('neutral', nx, cy + sp + 42);
    // Vφ annotation
    drawVAnnotation(ctx, nx + 4, cy - 4, nx + 4, yA + 4, 'Vφs', '#58a6ff', -18);
  } else {
    // Delta source: three sources forming a triangle
    const dx = srcX - 30;  // left side of delta
    const rx = srcX + 40;  // connection points going right
    for (let i = 0; i < 3; i++) {
      const j = (i + 1) % 3;
      // Vertical delta branch
      const my = (ys[i] + ys[j]) / 2;
      ctx.strokeStyle = pc[i]; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(dx, ys[i]); ctx.lineTo(dx, my - 14); ctx.stroke();
      drawACSourceV(ctx, dx, my, pc[i]);
      ctx.beginPath(); ctx.moveTo(dx, my + 14); ctx.lineTo(dx, ys[j]); ctx.stroke();
      // Horizontal wire from junction to terminal
      ctx.beginPath(); ctx.moveTo(dx, ys[i]); ctx.lineTo(lineL, ys[i]); ctx.stroke();
      // Terminal dot
      drawDot(ctx, lineL, ys[i], pc[i]);
      // Phase label
      ctx.fillStyle = pc[i]; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(LABELS[i], lineL + 1, ys[i] - 10);
      // Polarity
      ctx.font = '9px sans-serif';
      ctx.fillText('+', dx - 12, my - 10); ctx.fillText('−', dx - 12, my + 14);
    }
    // Vφ annotation
    drawVAnnotation(ctx, dx - 20, ys[0] + 4, dx - 20, ys[1] - 4, 'Vφs', '#58a6ff', -18);
  }

  // ═══ Draw Line Wires ═══
  for (let i = 0; i < 3; i++) {
    const y = ys[i];
    ctx.strokeStyle = pc[i]; ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(lineL, y); ctx.lineTo(lineR, y); ctx.stroke();
    // Current arrow
    const ax = (lineL + lineR) / 2;
    ctx.fillStyle = pc[i];
    ctx.beginPath();
    ctx.moveTo(ax + 8, y); ctx.lineTo(ax - 4, y - 5); ctx.lineTo(ax - 4, y + 5);
    ctx.closePath(); ctx.fill();
    // IL label
    ctx.fillStyle = '#f78166'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('I' + LABELS[i], ax, y - 9);
  }
  // IL magnitude label
  ctx.fillStyle = '#f78166'; ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('I_L = ' + fmtV(res.IlL) + ' A', (lineL + lineR) / 2, yC + 20);

  // ═══ Draw VL annotation between lines A and B ═══
  const vlx = lineL + 18;
  drawVAnnotation(ctx, vlx, yA + 6, vlx, yB - 6, 'V_L', '#d29922', -18);

  // ═══ Draw Load ═══
  if (ldY) {
    const nx = ldX + 55;
    for (let i = 0; i < 3; i++) {
      const y = ys[i];
      // Wire from terminal to impedance
      ctx.strokeStyle = pc[i]; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(lineR, y); ctx.lineTo(ldX - 32, y); ctx.stroke();
      drawDot(ctx, lineR, y, pc[i]);
      // Impedance zigzag
      drawZigzagH(ctx, ldX - 32, y, ldX + 32, y, pc[i]);
      // Wire from impedance to neutral
      ctx.beginPath(); ctx.moveTo(ldX + 32, y); ctx.lineTo(nx, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(nx, y); ctx.lineTo(nx, cy); ctx.stroke();
      // Iφ label
      ctx.fillStyle = pc[i]; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('Iφ' + LABELS[i], ldX, y - 12);
      // Phase label at terminal
      ctx.font = 'bold 11px sans-serif';
      ctx.fillText(LABELS[i], lineR - 1, y - 10);
    }
    // Neutral dot & label
    drawDot(ctx, nx, cy, '#8b949e');
    ctx.fillStyle = '#8b949e'; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'left';
    ctx.fillText('N', nx + 8, cy + 4);
    // Neutral wire down
    ctx.strokeStyle = '#8b949e40'; ctx.lineWidth = 1; ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.moveTo(nx, cy); ctx.lineTo(nx, cy + sp + 30); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#8b949e'; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('neutral', nx, cy + sp + 42);
    // Vφ annotation
    drawVAnnotation(ctx, nx - 4, cy + 4, nx - 4, yA + 4, 'Vφl', '#3fb950', 14);
    // Z label
    ctx.fillStyle = '#d2a8ff'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Z = ' + res.Zm + '∠' + (res.Za * 180 / Math.PI).toFixed(0) + '°', ldX, yC + 20);
  } else {
    // Delta load
    const dx = ldX + 30;
    for (let i = 0; i < 3; i++) {
      const j = (i + 1) % 3;
      const y = ys[i];
      // Wire from terminal to junction
      ctx.strokeStyle = pc[i]; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(lineR, y); ctx.lineTo(dx, y); ctx.stroke();
      drawDot(ctx, lineR, y, pc[i]);
      drawDot(ctx, dx, y, pc[i]);
      // Delta branch: vertical impedance between phase i and j
      const my = (ys[i] + ys[j]) / 2;
      ctx.beginPath(); ctx.moveTo(dx, ys[i]); ctx.lineTo(dx, my - 22); ctx.stroke();
      drawZigzagV(ctx, dx, my, pc[i]);
      ctx.beginPath(); ctx.moveTo(dx, my + 22); ctx.lineTo(dx, ys[j]); ctx.stroke();
      // Iφ label
      ctx.fillStyle = pc[i]; ctx.font = '9px sans-serif'; ctx.textAlign = 'left';
      ctx.fillText('Iφ' + LABELS[i] + LABELS[j], dx + 8, my + 3);
      // Phase label at terminal
      ctx.fillStyle = pc[i]; ctx.font = 'bold 11px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText(LABELS[i], lineR - 1, y - 10);
    }
    // Vφ annotation
    drawVAnnotation(ctx, dx + 4, ys[0] + 6, dx + 4, ys[1] - 6, 'Vφl', '#3fb950', 16);
    // Z label
    ctx.fillStyle = '#d2a8ff'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Z = ' + res.Zm + '∠' + (res.Za * 180 / Math.PI).toFixed(0) + '°', dx + 4, yC + 20);
  }
}

// ── Drawing helpers ──

function drawDot(ctx, x, y, color) {
  ctx.beginPath(); ctx.arc(x, y, 3.5, 0, Math.PI * 2);
  ctx.fillStyle = color; ctx.fill();
  ctx.strokeStyle = '#0d1117'; ctx.lineWidth = 1; ctx.stroke();
}

function drawACSourceH(ctx, x1, y, x2, y2, color) {
  // Horizontal AC source: circle with sine wave, centered between x1 and x2
  const cx = (x1 + x2) / 2, r = 13;
  // Wires to circle
  ctx.strokeStyle = color; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(cx - r, y); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx + r, y); ctx.lineTo(x2, y); ctx.stroke();
  // Circle
  ctx.beginPath(); ctx.arc(cx, y, r, 0, Math.PI * 2);
  ctx.fillStyle = '#0d1117'; ctx.fill();
  ctx.strokeStyle = color; ctx.lineWidth = 1.8; ctx.stroke();
  // Sine wave inside
  ctx.strokeStyle = color; ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let t = -1; t <= 1; t += 0.05) {
    const px = cx + t * (r - 3);
    const py = y - Math.sin(t * Math.PI) * (r * 0.45);
    t === -1 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.stroke();
}

function drawACSourceV(ctx, x, my, color) {
  // Vertical AC source
  const r = 13;
  ctx.beginPath(); ctx.arc(x, my, r, 0, Math.PI * 2);
  ctx.fillStyle = '#0d1117'; ctx.fill();
  ctx.strokeStyle = color; ctx.lineWidth = 1.8; ctx.stroke();
  // Sine wave inside (rotated 90°)
  ctx.strokeStyle = color; ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (let t = -1; t <= 1; t += 0.05) {
    const py = my + t * (r - 3);
    const px = x + Math.sin(t * Math.PI) * (r * 0.45);
    t === -1 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.stroke();
}

function drawZigzagH(ctx, x1, y, x2, y2, color) {
  // Horizontal zigzag impedance symbol
  const len = x2 - x1;
  const segs = 6;
  const segW = len / segs;
  const amp = 8;
  ctx.strokeStyle = color; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x1, y);
  for (let s = 0; s < segs; s++) {
    const sx = x1 + s * segW;
    if (s === 0) {
      ctx.lineTo(sx + segW * 0.25, y - amp);
    } else {
      ctx.lineTo(sx + segW * 0.25, y - amp);
    }
    ctx.lineTo(sx + segW * 0.75, y + amp);
    ctx.lineTo(sx + segW, y);
  }
  ctx.stroke();
  // Z label
  ctx.fillStyle = color; ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('Z', (x1 + x2) / 2, y + amp + 12);
  ctx.textBaseline = 'alphabetic';
}

function drawZigzagV(ctx, x, my, color) {
  // Vertical zigzag impedance symbol
  const halfH = 20;
  const segs = 5;
  const segH = (halfH * 2) / segs;
  const amp = 7;
  const y1 = my - halfH;
  ctx.strokeStyle = color; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(x, y1);
  for (let s = 0; s < segs; s++) {
    const sy = y1 + s * segH;
    ctx.lineTo(x + amp, sy + segH * 0.25);
    ctx.lineTo(x - amp, sy + segH * 0.75);
    ctx.lineTo(x, sy + segH);
  }
  ctx.stroke();
  // Z label
  ctx.fillStyle = color; ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
  ctx.fillText('Z', x + amp + 4, my);
  ctx.textBaseline = 'alphabetic';
}

function drawVAnnotation(ctx, x1, y1, x2, y2, label, color, offsetX) {
  // Voltage annotation arrow between two points
  ctx.strokeStyle = color + '90'; ctx.lineWidth = 1.2;
  ctx.setLineDash([3, 3]);
  ctx.beginPath(); ctx.moveTo(x1 + offsetX, y1); ctx.lineTo(x2 + offsetX, y2); ctx.stroke();
  ctx.setLineDash([]);
  // Arrowheads
  const headL = 5;
  ctx.fillStyle = color + '90';
  // Top arrow (pointing up)
  ctx.beginPath();
  ctx.moveTo(x1 + offsetX, y1); ctx.lineTo(x1 + offsetX - 3, y1 + headL); ctx.lineTo(x1 + offsetX + 3, y1 + headL);
  ctx.closePath(); ctx.fill();
  // Bottom arrow (pointing down)
  ctx.beginPath();
  ctx.moveTo(x2 + offsetX, y2); ctx.lineTo(x2 + offsetX - 3, y2 - headL); ctx.lineTo(x2 + offsetX + 3, y2 - headL);
  ctx.closePath(); ctx.fill();
  // Label
  ctx.fillStyle = color; ctx.font = '9px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText(label, (x1 + x2) / 2 + offsetX, (y1 + y2) / 2 - 2);
}

// ── Phasor Diagram ──
function drawPhasors() {
  const W = phasorC.width, H = phasorC.height;
  const ctx = pCtx;
  ctx.clearRect(0, 0, W, H);
  const cx = W / 2, cy = H / 2;
  const maxR = Math.min(W, H) / 2 - 35;

  // Grid circles
  ctx.strokeStyle = '#ffffff08';
  ctx.lineWidth = 1;
  for (let r = maxR / 3; r <= maxR; r += maxR / 3) {
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
  }
  ctx.strokeStyle = '#ffffff15';
  ctx.beginPath(); ctx.moveTo(10, cy); ctx.lineTo(W - 10, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, 10); ctx.lineTo(cx, H - 10); ctx.stroke();

  const r = res;
  const baseAngle = time * (+sFreq.value) * 2 * Math.PI;

  // Normalize to fit: pick max of VlL or VpL for voltage scale
  const maxV = Math.max(r.VlS, r.VlL, r.VpS, r.VpL);
  const maxI = Math.max(r.IlL, r.IpL);
  const vScale = maxR * 0.7 / (maxV || 1);
  const iScale = maxR * 0.5 / (maxI || 1);

  // Draw voltage phasors (line voltages)
  for (let i = 0; i < 3; i++) {
    const ang = baseAngle + PHASE_OFF[i];
    const mag = r.VpL * vScale;
    drawArrow(ctx, cx, cy, ang, mag, COLORSARR[i], 2.5);
    // Label
    const lx2 = cx + Math.cos(ang) * (mag + 14);
    const ly2 = cy - Math.sin(ang) * (mag + 14);
    ctx.fillStyle = COLORSARR[i];
    ctx.font = 'bold 11px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('V' + LABELS[i], lx2, ly2 + 4);
  }

  // Draw current phasors (lagging by Za)
  for (let i = 0; i < 3; i++) {
    const ang = baseAngle + PHASE_OFF[i] - r.Za;
    const mag = r.IpL * iScale;
    drawArrow(ctx, cx, cy, ang, mag, COLORSARR[i], 1.5, true);
    // Label
    const lx2 = cx + Math.cos(ang) * (mag + 14);
    const ly2 = cy - Math.sin(ang) * (mag + 14);
    ctx.fillStyle = COLORSARR[i];
    ctx.font = '10px sans-serif';
    ctx.fillText('I' + LABELS[i], lx2, ly2 + 4);
  }

  // Legend
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#8b949e';
  ctx.fillText('— Voltage (Vφ)', 8, H - 22);
  ctx.fillText('--- Current (Iφ)', 8, H - 8);
  // Angle arc showing θ
  if (Math.abs(r.Za) > 0.01) {
    const arcR = 30;
    const a1 = baseAngle + PHASE_OFF[0];
    const a2 = a1 - r.Za;
    ctx.strokeStyle = '#d2a8ff60';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(cx, cy, arcR, -a1, -a2, r.Za > 0);
    ctx.stroke();
    const am = (a1 + a2) / 2;
    ctx.fillStyle = '#d2a8ff';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('θ', cx + Math.cos(am) * (arcR + 10), cy - Math.sin(am) * (arcR + 10) + 3);
  }
}

function drawArrow(ctx, cx, cy, angle, length, color, width, dashed) {
  const ex = cx + Math.cos(angle) * length;
  const ey = cy - Math.sin(angle) * length;
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  if (dashed) ctx.setLineDash([5, 4]);
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(ex, ey);
  ctx.stroke();
  ctx.setLineDash([]);
  // Arrowhead
  const hl = 8;
  const ha = Math.atan2(cy - ey, ex - cx);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(ex, ey);
  ctx.lineTo(ex - hl * Math.cos(ha - 0.35), ey + hl * Math.sin(ha - 0.35));
  ctx.lineTo(ex - hl * Math.cos(ha + 0.35), ey + hl * Math.sin(ha + 0.35));
  ctx.closePath();
  ctx.fill();
}

// ── Waveforms ──
function drawWaveforms() {
  const W = waveC.width, H = waveC.height;
  const ctx = wCtx;
  ctx.clearRect(0, 0, W, H);

  const freq = +sFreq.value;
  const r = res;
  const midY = H / 2;
  const plotL = 60, plotR = W - 10;
  const plotW = plotR - plotL;

  // Grid
  ctx.strokeStyle = '#ffffff08';
  ctx.lineWidth = 1;
  for (let y = 20; y < H - 10; y += (H - 30) / 6) {
    ctx.beginPath(); ctx.moveTo(plotL, y); ctx.lineTo(plotR, y); ctx.stroke();
  }
  ctx.strokeStyle = '#ffffff20';
  ctx.beginPath(); ctx.moveTo(plotL, midY); ctx.lineTo(plotR, midY); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(plotL, 20); ctx.lineTo(plotL, H - 10); ctx.stroke();

  // Axis labels
  ctx.fillStyle = '#484f58';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('+V', plotL - 4, 26);
  ctx.fillText('0', plotL - 4, midY + 3);
  ctx.fillText('−V', plotL - 4, H - 12);
  ctx.textAlign = 'center';
  ctx.fillText('Time →', (plotL + plotR) / 2, H - 1);

  const yScale = (H / 2 - 25);
  const maxV = r.VpL || 1;
  const cycles = 2;

  // Draw voltage waveforms
  for (let p = 0; p < 3; p++) {
    ctx.strokeStyle = COLORSARR[p];
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= plotW; i++) {
      const t = (i / plotW) * cycles;
      const v = Math.sin(2 * Math.PI * freq * t + PHASE_OFF[p] + time * freq * 2 * Math.PI);
      const x = plotL + i;
      const y = midY - v * yScale * 0.8;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
  }

  // Draw current waveforms (dashed, smaller)
  for (let p = 0; p < 3; p++) {
    ctx.strokeStyle = COLORSARR[p];
    ctx.lineWidth = 1.2;
    ctx.setLineDash([5, 4]);
    ctx.beginPath();
    for (let i = 0; i <= plotW; i++) {
      const t = (i / plotW) * cycles;
      const v = Math.sin(2 * Math.PI * freq * t + PHASE_OFF[p] - r.Za + time * freq * 2 * Math.PI);
      const x = plotL + i;
      const y = midY - v * yScale * 0.5;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Legend
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'left';
  for (let p = 0; p < 3; p++) {
    ctx.fillStyle = COLORSARR[p];
    ctx.fillText('V' + LABELS[p], plotR + 2 - 90 * (3 - p), 14);
  }
  ctx.fillStyle = '#8b949e';
  ctx.fillText('— Voltage   --- Current', plotL + 4, 14);
}

// ── Animation ──
let time = 0;
let lastTS = 0;

function animate(ts) {
  if (!lastTS) lastTS = ts;
  const dt = (ts - lastTS) / 1000;
  lastTS = ts;
  time += dt * (+sFreq.value);
  drawPhasors();
  drawWaveforms();
  requestAnimationFrame(animate);
}

compute();
requestAnimationFrame(animate);
</script>
</body>
</html>
